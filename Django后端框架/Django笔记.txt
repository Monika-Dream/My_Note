Django 框架
-------------------------------------------------------------- Start

 - 1.创建虚拟环境
python -m venv 项目名称

 - 2.开启虚拟
Script/activate.bat
powershell 命令行，脚本换成 Activate.ps1

 - 3.关闭虚拟
Script/deactivate.bat

 - 4.下载 Django 库 ( 跳到目录之内下载 )
pip install django

 - 5.创建 Django 项目
django-admin startproject 项目名字

 - 6.创建子应用(可选)
python manage.py startapp name
django-admin startapp areas

-------------------------------------------------------------- 需要的文件目录

meiduo_mall
    - apps                          存放子应用
    - celery_tasks                  这个无强制规定
    - libs                          存放自己导的第三方库
    - logs                          日志存放
    - meiduo_mall                   自动生成的
    - templates                     模板文件存放文件夹(强制需要)
    - utils                         存放项目自己定义的公共函数或类等
    - manage.py                     目录下执行命令

-------------------------------------------------------------- Django 文件刨析

settings.py - 项目的整体设置

urls.py 	- 进行路由匹配

wsgi.py 	- 项目与 WSGI 兼容的 Web 服务器入口

manage.py 	- 项目管理文件

-------------------------------------------------------------- Django 运行

 - 只能运行 manage.py 文件(需要在虚拟环境中)( 默认 127.0.0.1 )
 	 - python manage.py runserver

-------------------------------------------------------------- Django 创建子应用

 - 需要在 manage.py 目录下执行命令
python manage.py startapp name

-------------------------------------------------------------- Django 子文件刨析

 - admin.py 		文件跟网站的后台管理配置相关

 - apps.py 			文件用于配置当前子应用的相关信息

 - migrations 		目录用于存放数据库迁移历史文件

 - models.py 		文件用户保存数据库模型类

 - tests.py 		文件用于开发测试用例, 编写单元测试

 - views.py 		文件用于编写 Web 应用视图

-------------------------------------------------------------- Django 注意实现

 - 可以选择将指针放到准确目录上, 将python 解释器路径从新设置
 	 - 至 Script 目录下
 	 - 执行 Activate.ps1/activate.bat 直到命令行前面出现 绿色(文件夹名称) 标识
 	 	 - 即为成功进入虚拟环境

-------------------------------------------------------------- 主文件注册子目录

 - 主settings文件
 	 - 创建 子应用 而不注册会出错

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'MonikaAPP'
]

-------------------------------------------------------------- ORM 是什么

 - 一套面向对象的语法格式
 - Django 以使用
 - 调用方法即可使用不同的数据库, 一套语法解决多个数据库语言不同步问题

		ORM								DB
		 类 				<->			  数据表
		对象 			<->			  数据行
		属性				<->			   字段

-------------------------------------------------------------- ORM 使用

 - 已忽略文件的自动导入代码
 - 转到 子app 中的 models.py 文件中写入类
1.我们的模型类需要继承自 models.Model
2.系统会自动为我们添加一个逐渐 - id
3.字段
	- 字段名=model.类型(选项)
		 - 字段名实则就是数据表的字段名
		 - 字段名不要使用 Mysql Python 等关键字
4.关于本章可以参考 Mysql 笔记

class Book(models.Model):
	# 系统会自动为我们添加一个逐渐 - id
	name = models.CharField( Max_length=10 )		===      			varchar(10)

class Person(models.Model):
	# 系统会自动为我们添加一个逐渐 - id
	name = models.CharField( Max_length=10 )		===      			varchar(10)
	gender = models.BooleanField()					=== 				布尔值	
	book = models.ForeignKey(BookInfo,on_delete = model.CASCADE) === 	外键

-------------------------------------------------------------- ORM 模型迁移

1.根据你所写入的内容形成对应的 SQL 语句
 - 生成对应的迁移文件
 	- python manage.py makemigrations
 - 执行迁移 (执行文件)
	- python manage.py migrate

2.检测不到变化请移步至子文件导入

3.执行文件成功后表在哪?
 - 移步至 setting.py 文件
 
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

-------------------------------------------------------------- 站点管理

 - 界面本地化
 - 创建管理员
 - 注册模型类
 - 发布内容到数据库
     - 打开网站后,网址加入 /admin
     - 创建超级用户管理员
     - python manage.py createsuperuser
         - 注意密码不显示

-------------------------------------------------------------- Settings 选项

# 语言
LANGUAGE_CODE = 'zh-Hans'
# 时区
TIME_ZONE = 'Asia/Shanghai'

USE_I18N = True

USE_TZ = True

-------------------------------------------------------------- views 视图

 - 打开 views 文件
 - 所谓的视图实际就是 Python 函数
 - 视图函数有两个要求
     - 视图函数第一个参数是接受请求
     - 必须返回一个响应
# requests 参数实则就是下面的
# from django.http import HttpRequest
HttpResponse('响应体', content_type='image/jpeg' <- 响应格式)
from django.http import HttpResponse
def index(requests):

    return HttpResponse("ok")

-------------------------------------------------------------- 路由匹配

 - 打开 urls.py 
from django.contrib import admin
from django.urls import path
from MonikaAPP.views import index
urlpatterns = [
    path('admin/', admin.site.urls),
    path("index/", index)
]

-------------------------------------------------------------- 路由匹配2

 - 子应用创建 urls 的方式
 - 右键新建 urls.py 文件

from django.urls import path
from 文件名.views import 函数名
urlpatterns = [
    # path(路由,路由函数名)  
    path("index/",函数名)
]


 - 总路由文件
from django.contrib import admin
from django.urls import path
from django.urls import include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('访问子应用路径', include('文件名.urls'))
]

-------------------------------------------------------------- 模板

 - 创建文件夹 templantes
 - 创建文件名对应目录 例: Monika
     - 存放 html,css,js 文件
 - 打开 Settings文件
 - 找到 TEMPLATES["DIRS"] 位置
     - 参照下面路径配置方式
     - ['DIRS': [BASE_DIR / 'templantes'],]
 - 返回需要输出模板文件的地方
 - 打开 views 文件

def index(requests):
    print(requests)
    return render(requests,'Monika/index.html')

-------------------------------------------------------------- 模板渲染数据(了解)

def index(requests):
    object = {
        name:"monika"
    }
    return render(requests,'Monika/index.html',context=object)

<div>{{name}}</div>

-------------------------------------------------------------- setting部分内容讲解

BASE_DIR = 内部文件的最近外层文件
# C:\Users\Lenovo\Desktop\Django学习\学习  ,   MonikaAPP/学习

DEBUG = True
# 开启调试模式
# 项目部署时请关闭

ALLOWED_HOSTS = ['*',"127.0.0.1"]
# 允许以什么样的形式访问我们的项目
# 默认 127.0.0.1
# * 表示可以使用 IP, 也可以使用 127.0.0.1

-------------------------------------------------------------- 静态文件

 - 在跟文件底下创建 static 文件, 可以将静态文件(js/css/html/img) 文件放入

 - settings 文件加入配置, 告知文件路径( DEBUG 需要为 TRUE )
    STATICFILES_DIRS = [ BASE_DIR / 'static' ]
    # http://127.0.0.1:8000/static/001.jpg 当时访问路径

-------------------------------------------------------------- apps 了解

 - 和子应用配置相关的

-------------------------------------------------------------- 数据库修改为 MySQL

 - 开启虚拟环境
 - pip install mysqlclient
 - 接下来开启 MySQL 并且创建一个库
create database 名字

到 settings 中的 DATABASES 进行配置

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',   使用什么命令
        "HOST":"127.0.0.1",                     主机地址
        "PORT":3306,                            端口号
        "USER":"root",                          权力
        "PASSWORD":"sxhmzz840845135",           密码
        'NAME': "django学习",                   数据库名
    }
}

-------------------------------------------------------------- 关于选项

 - unique = true                        不许重复,默认值是False
 - default = 1                          默认值
 - null = False                         非空
 - Max_length = 20                      最大 20 字符, 仅可用在 CharField 上
 - choices = 有序元组变量名              只能在这里面选择(约束数据),填写 1 / 2
     - 有序元组变量名 = ( (1,'male'),(2,"female") )
 - blank                                如果为True，则该字段允许为空白，默认值是False
 - db_column                            字段的名称，如果未指定，则使用属性的名称
 - db_index                             若值为True, 则在表中会为此字段创建索引，默认值是False

 - primary_key                          若为True，则该字段会成为模型的主键字段，
                                             - 默认值是False，一般作为AutoField的选项使用
 - related_name='subs'                  详细请看关联查询 
                                             - 由一到多的访问模型中, 系统会为我们自动添加一个 关系模型类名小写_set 字段
                                             - 与当前有关联的内容
                                             - # 查询书籍为 1 的所有人物信息 
                                             - book = BookInfo.objects.get(id=1)
                                             - book.peopleinfo_set.all()
                                             - 而 related_name 就是设置 peopleinfo_set 的换名的
                                             - 例如 requests.user.subs ( 一对多, subs 绑定了 user id )

-------------------------------------------------------------- 关于 models.

models.CharField()                                                  varchar()
models.SmallIntegerField(choices= ,default= )                       内容约束
models.BooleanField()                                               True/False
models.DateField()                                                  日期
models.ForeignKey(另一个类,on_delete=models.CASCADE)                 外键约束
     - CASCADE          主表没了, 子表一并删除
     - PROTECT          子表还在则无法删除主表, 抛出异常( ProtectedError )
     - SET_NULL         主表没了, 无关紧要, 子表继续执行
     - SET_DEFFAULT     候选人
     - SET              选举候选人(设置特定值或调用特定方法)
     - DO_NOTHING       关我屁事

 - 补充:

     - models.AutoField()   
         - 自动增长的IntegerField，通常不用指定，
         - 不指定时Django会自动创建属性名为id的自动增长属性

     - models.BooleanField()    
         - 布尔字段，值为True或False

     - models.NullBooleanField()    
         - 支持Null、True、False三种值

     - models.CharField()   
         - 字符串，参数max_length表示最大字符个数

     - models.TextField()   
         - 大文本字段，一般超过4000个字符时使用

     - models.IntegerField()    
         - 整数

     - models.DecimalField()    
         - 十进制浮点数， 参数max_digits表示总位数， 参数decimal_places表示小数位数

     - models.FloatField()  
         - 浮点数

     - models.DateField()   
         - 日期， 参数auto_now表示每次保存对象时，自动设置该字段为当前时间，
         - 用于"最后一次修改"的时间戳，它总是使用当前日期，默认为False； 
         - 参数auto_now_add表示当对象第一次被创建时自动设置当前时间，用于创建的时间戳，
         - 它总是使用当前日期，默认为False; 
         - 参数auto_now_add和auto_now是相互排斥的，组合将会发生错误

     - models.TimeField()   
         - 时间，参数同DateField

     - models.DateTimeField()   
         - 日期时间，参数同DateField

     - models.FileField()   
         - 上传文件字段

     - models.ImageField()  
         - 继承于FileField，对上传的内容进行校验，确保是有效的图片

-------------------------------------------------------------- 模型类的基本定义(外键)

 - 模型类 需要继承自 models.Model
    - id 默认生成
    - 一个表就是一个类
    - 字段就是属性
        - 属性名 = models.类型( 选项 )
        - 属性名就是字段名 
        - 不要使用连续的下划线 __
 - 选项 (是否唯一, 默认值, CharField 必须有 Max_length)
 - 默认表的名称时 子应用名 + 类名
     - 修改表的名字


例子:
class BookInfo(models.Model):
    name = models.CharField(max_length=10,unique=true)
    pub_date = models.DateField(null=True)
    readcount = models.IntegerField(default=0)
    commentcount = models.IntegerField(default=0)
    isdelete = models.BooleanField(default=False)

    # 改变表名
    class Meta:
        db_table = 'bookinfo' 

class PepoleInfo(models.Model):

    gender_choice = (
        (1,'male'),
        (2,"female")
    )

    name=models.CharField(max_length=10,unique=True)
    gender = models.SmallIntegerField(choices=gender_choice,default=1)
    description = models.CharField(max_length=100,null=True)
    is_delete = models.BooleanField(default=False)

    #外键 - 系统会自动为外键添加 _id
    book=models.ForeignKey(BookInfo)
    #这里确实进行了关联, book_id 与 BookInfo 的 ID 进行了关联

-------------------------------------------------------------- 业务流程中实现增删改查的地方

 - 在 views.py 文件中
from django.shortcuts import render
from django.http import HttpResponse
from book.models import BookInfo
def index(requests):
    #实现 增删改查 的地方
    books = BookInfo.objects.all()
    print(books)
    return HttpResponse("ok")

-------------------------------------------------------------- Shell 工具

 - Django 的 manage 工具提供了 shell 命令,帮助我们配置好当前工程的运行环境
     - 可以在终端中直接执行 Python 指令
     - 注意让终端同样进入虚拟环境

 - python manage.py shell
      - 文件内容更改需要重新执行

from 文件.models import 类名
>>> 类名.objects.all()                            #打印类内容
# - 类似与 select * form ...
# 这里会打印类, 如果没有重写 类 的 __str__ 方法, 就会打印 class 之类的
# 需要重写 __str__ 方法
# def __str__(self):
#    return self.name
# <QuerySet [<BookInfo: 射雕英雄传>, <BookInfo: 天龙八部>, <BookInfo: 笑傲江湖>, <BookInfo: 雪山飞狐>]>

-------------------------------------------------------------- MySQL 数据的增删改查

                                             - 增加数据(views.py)
from book.models import BookInfo
# (方式一)
book = BookInfo(
    name = "生命的备件",
    pub_date = "2016-8-26",
    readcount = 10
)
#上方只是将需要的数据写入了内存, 需要执行下面的命令
book.save()

# (方式二)
# - objects 相当于一个代理, 帮助我们实现增删改查
BookInfo.objects.create(
    name = "Clannad",
    pub_date = "2016-8-26",
    readcount = 10
)

                                             - 修改数据(views.py)
# (方式一)
# select * from BookInfo where id=6
book = BookInfo.objects.get(id=6)
book.name = "紫罗兰的永恒花园"
#上方只是将需要的数据写入了内存, 需要执行下面的命令
book.save()

# (方式二)
BookInfo.objects.filter(id=6).update(name="未来日记",commentcount=666)

                                             - 删除数据(views.py)
# (方式一)
book = BookInfo.objects.get(id=1)
book = BookInfo.objects.filter(id=5)
# 物理删除 / 逻辑删除( is_delete = False )
book.delete()
                                             - 查询数据(views.py)

get - 查询单一结果, 如果不存在抛出 DoesNotExist 异常
all - 查询多个结果
count - 查询结果数量

# 查询单一结果
try:
    book = BookInfo.objects.get(id=1)
except BookInfo.DoesNotExist:
    print("查询结果不存在")

# 查询多个结果
book = BookInfo.objects.all()

# 查询结果数量
book = BookInfo.objects.all().count()
book = BookInfo.objects.count()

二. 过滤查询()

filter  过滤出多个结果
exclude 排除掉符合条件剩下的结果
get     过滤单一结果

BookInfo.objects.filter(属性名__运算符=值)     获取 N 个结果
BookInfo.objects.exclude(属性名__运算符=值)    获取 N 个结果
BookInfo.objects.get(属性名__运算符=值)        获取 1 个结果 或者 开摆

#查询编号为一的图书
BookInfo.objects.get(id=1)              #简写形式
BookInfo.objects.get(id__exact = 1)     #完整形式
BookInfo.objects.get(pk=1)              #另类方式

#查询书名中包含'湖'的图书
BookInfo.objects.filter(name__contains='湖')

#查询书名中'部'结尾的图书
BookInfo.objects.filter(name__endswith='部')

#查询书名为空的图书
BookInfo.objects.filter(name__isnull=True)

#查询编号为 1, 3, 5 的图书
# select * from peopleinfo where id in (1,3,5,7,9);
BookInfo.objects.filter(id__in=[1,3,5])

#查询编号大于3图书
# 大于 gt 大于等于 gte
# 小于 lt 小于等于 lte
# 不等于 BookInfo.objects.exclude()
BookInfo.objects.filter(id__gt=3)

#查询1980年发布的图书
BookInfo.objects.filter(pub_date__year=1980)

#查询 1980 1月1日 之后年发布的图书
BookInfo.objects.filter(pub_date__gt=1980-1-1)

-------------------------------------------------------------- F 对象( 两个属性之间进行比较 )

 - 进行两个属性的比较, F 对象
     - 注意大写 F
from django.db.models import F
模型类名.objects.filter(属性名__运算符=F('第二个属性名'))
BookInfo.objects.filter(readcount__gt=F('commentcount'))

#查询阅读量大于两倍评论量的图书
BookInfo.objects.filter(readcount__gt=F('commentcount')*2)

-------------------------------------------------------------- Q 对象( 两个属性之间进行比较 )

 - 多个过滤器逐个调用表示逻辑与关系, 同 SQL 语句中的 Where 与 and 关键字

#阅读量大于 20 且标号小于 3 的图书
BookInfo.objects.filter(readcount__gt=20,id__lt=3)                     #并且
BookInfo.objects.filter(readcount__gt=20).filter(id__lt=3)             #并且
BookInfo.objects.filter(Q(readcount__gt=20)&Q(id__lt=3))               #并且

from django.db.models import Q
模型类名.objects.filter(Q(属性名__运算符=值)|Q(属性名__运算符=值))        #或者
模型类名.objects.filter(Q(属性名__运算符=值)&Q(属性名__运算符=值))        #并且
模型类名.objects.filter(~Q(属性名__运算符=值)&~Q(属性名__运算符=值))      #除了 not/~Q

-------------------------------------------------------------- 聚合函数和排序函数

 - 聚合函数()
使用 aggregate() 过滤器调用聚合函数, 聚合函数包括 [Avg平均, Count数量, Max最大, Min最小, Sum求和]
     被定义在 django.db.models 中

#查询图书的总阅读量
from django.db.models import Sum
BookInfo.objects.aggregate(Sum('readcount'))
返回 {'readcount': 126}

 - 排序函数()
# select * from peopleinfo order by id [desc]

BookInfo.objects.all().order_by('readcount')    从小到大
BookInfo.objects.all().order_by('-readcount')   从大到小

GoodsChannel.objects.order_by('group_id', 'sequence')
     - 排序多个

-------------------------------------------------------------- 级联排序 ( 关联查询 )

 - 关联查询()          
由一到多的访问模型中, 系统会为我们自动添加一个 关系模型类名小写_set 字段
与当前有关联的内容

 # 查询书籍为 1 的所有人物信息 
book = BookInfo.objects.get(id=1)
book.peopleinfo_set.all()

 # 查询人物为 1 的书籍信息
person = peopleinfo.objects.get(id=1)
person.book
person.book.name

-------------------------------------------------------------- 关联查询和管理过滤查询

#语法形式
# 查询为 1 的数据,条件为 N
# 模型类名.objects.(关联模型类名小写__字段名__运算符=值)

#查询图书,要求图书人物为 '郭庆'
BookInfo.objects.filter(peopleinfo__name='郭靖')

#查询图书, 要求图书中人物包含 八
BookInfo.objects.filter(peopleinfo__description__contains='八')

#查询书名为天龙八部的所有人物
PeopleInfo.objects.filter(book__name="天龙八部")

#查询图书阅读量大于 30 的所有人物
PeopleInfo.objects.filter(book__readcount__gt=30)

-------------------------------------------------------------- 一切的运算符

__exact = <str>             =                   可以省略    
__contains = <str>          包含           
__endswith = <str>          包含且结尾为     
__isnull = <boolean>        是否为空
__in = <list>               包含在列表
__gt = <number>             大于
__lt = <number>             小于
__gte = <number>            大于等于
__lte = <number>            小于等于
__year = <number>           需要四位数

-------------------------------------------------------------- 查询集 QuerySet

                                                                1.惰性执行()
创建查询集不会访问数据库，直到调用数据时，才会访问数据库，
    - 调用数据的情况包括迭代、序列化、与if合用
例如，当执行如下语句时，并未进行数据库查询，只是创建了一个查询集books

books = BookInfo.objects.all()

继续执行遍历迭代操作后，才真正的进行了数据库的查询

for book in books:
    print(book.name)



                                                                2.缓存执行()
经过存储后，可以重用查询集
    - 第二次使用缓存中的数据。

books=BookInfo.objects.all()
[book.id for book in books]



                                                                3.限制查询集()
 - 不支持负数
books = BookInfo.objects.all()[0:2]
<QuerySet [<BookInfo: 射雕英雄传>, <BookInfo: 天龙八部>]>


                                                                4.分页()
books = BookInfo.objects.all()
from django.core.paginator import Paginator
paginator=Paginator(books,2)
page_books = paginator.page(1)
total_page=paginator.num_pages

-------------------------------------------------------------- HttpRequest 对象(传参)

 - 提取URL的特定部分，如/weather/beijing/2018，可以在服务器端的路由中用正则表达式截取；
 - 查询字符串（ query string )，形如 key1=value1&key2=value2；
 - 请求体（ body ）中发送的数据，比如表单数据、json、xml；
 - 在http报文的头（ header ）中。

from django.urls import path
from book.views import shop
urlpatterns=[
    path('<city_id>/<shop_id>/',shop)
]

def shop(request, city_id, shop_id):
    pass

-------------------------------------------------------------- 查询字符串( Query String )

 - query 参数
 - 请求路径?查询字符串
 - QueryDict 区别于普通字典的为
     - 字典的特性
     - 一键多值,需要用  query_params.getlist("键名")  来获取值

def shop(request):
    query_params = request.GET
    print(query_params.get("键名"))

-------------------------------------------------------------- 传递 From 表单数据

 - Django 默认不允许我们发送 Post 请求
 - 想要发送 Post 请求需要在 setting文件 中
     - 将 MIDDLEWARE 对象的
     - 'django.middleware.csrf.CsrfViewMiddleware', 
     注释掉就行了

-------------------------------------------------------------- JSON 数据请求与发送

 - JSON 数据无法通过 requests.POST 获取
 - requests.body 获取会得到 二进制数据, 需要 decode() 解码, 解码之后会成为字符串
     - JSON 形式的字符串可以转换为 python 的字典
     - 需要导入 import json
     - json.loads(body)

 - 表单数据 requests.POST
 - JSON 数据 requests.body

-------------------------------------------------------------- 请求头

 - 可以通过 requests.META 属性获取请求头中的 headers 中的数据
     - requests.META 为字典类型

-------------------------------------------------------------- 转化器的使用( 在路径时就进行验证 )

 - 系统为我们提供了一些路由转换器位置在django.urls.converters.py

from django.urls import path
from book.views import shop
from django.urls import converters      #在路径时就进行验证

# <转换器名字:变量名>
# 转换器会对变量数据进行验证，正则的验证

urlpatterns=[
    path('<int:city_id>/<int:shop_id>/',shop)
]


DEFAULT_CONVERTERS = {
    'int': IntConverter(), # 匹配正整数，包含0
    'path': PathConverter(), # 匹配任何非空字符串，包含了路径分隔符
    'slug': SlugConverter(), # 匹配字母、数字以及横杠、下划线组成的字符串
    'str': StringConverter(), # 匹配除了路径分隔符（/）之外的非空字符串，这是默认的形式
    'uuid': UUIDConverter(), # 匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00
}

-------------------------------------------------------------- 自定义转化器的使用( 在路径时就进行验证 )

 - 比如：在工程根目录下，新建converters.py文件，用于自定义路由转换器
 - 转换器好像已经是 严格匹配了 无需再次 严格
class MobileConverter:
  """自定义路由转换器：匹配手机号"""
  # 匹配手机号码的正则
  regex = '1[3-9]\d{9}'

  def to_python(self, value):
      # 将匹配结果传递到视图内部时使用
      return int(value)

  def to_url(self, value):
      # 将匹配结果用于反向解析传值时使用
      return str(value)


from django.urls.converters import register_converter                  # 注册自定义路由转换器
# register_converter(自定义路由转换器, '别名')
register_converter(MobileConverter, 'mobile')

urlpatterns = []
# 使用自定义路由转换器

# 测试path()中自定义路由转换器提取路径参数：手机号 http://127.0.0.1:8000/18500001111/
# - 注意接受参数
path('<mobile:phone>/',register)

-------------------------------------------------------------- HttpResponse 对象

- 1. JsonResponse()
 - 将 Python 的 dist字典 转换成 JSON 格式

# 设置响应头Content-Type为application/json
from django.http import JsonResponse
info = {'name':'惠璃','age':"18"}
def response(request):
    return JsonResponse(data=info)

# 当数据为 列表包裹字典情况时
info = [
    {'name':'惠璃','age':'18'},
    {'name':'龙次','age':'18'}
]

def response(request):
    return JsonResponse( data=info, safe=False )

safe = 安全
safe = True  : 我们的数据为字典数据
safe = False : 我们的数据为非字典数据


-------------------------------------------------------------- 转化 JSON

import json as JSON 
from django.http import JsonResponse

 - 将 Python 的 dist字典 转换成 JSON 格式
     - return JsonResponse( data=info, safe=False )

 - JSON 形式的字符串可以转换为 python 的字典
     - JSON.loads()

 - 字典转化为字符串
     - json.dumps()

-------------------------------------------------------------- redirect 重定向

from django.shortcuts import redirect

def response(request):
    return redirect('/get_header')

-------------------------------------------------------------- Cookie饼干 && Session令牌 ( 状态保持 )


 - 1. 浏览器请求服务器是无状态的。
 - 2. 无状态：指一次用户请求时，
        - 浏览器、服务器无法知道之前这个用户做过什么，每次请求都是一次新的请求。
 - 3. 无状态原因：浏览器与服务器是使用 Socket 套接字进行通信的，
        - 服务器将请求结果返回给浏览器之后，
            - 会关闭当前的 Socket 连接，
            - 而且服务器也会在处理页面完毕之后销毁页面对象。
 - 4. 有时需要保持下来用户浏览的状态，比如用户是否登录过，浏览过哪些商品等
 - 5. 实现状态保持主要有两种方式：
        - 在客户端存储信息使用 Cookie
        - 在服务器端存储信息使用 Session

-------------------------------------------------------------- 饼干(Cookie)

 - 一些饼干... 一些饼干...
 - 追踪用户行为常用( html指纹技术? )
 - Cookie 是由服务器端生成
 - 下次请求服务器时会自动发送 Cookie( 浏览器开启 Cookie 情况下 )

                浏览器        第一次访问没有 Cookie 信息  ->    服务器
                浏览器        返回 Cookie                <-    服务器
                浏览器        请求携带 Cookie 信息        ->   服务器( 返回相关 Cookie 处理内容 )
                浏览器        请求携带 Cookie 信息        ->   服务器( 返回相关 Cookie 处理内容 )

 - Cookie = Key-Value 形式
 - Cookie 是基于域名安全的, 不同网站之间无法访问 Cookie

-------------------------------------------------------------- 设置饼干( 设置Cookie )

 - 设置 response 获取 requests      #生命周期
 - response.set_cookie(key, value, max_age = 秒)       #设置 Cookie (默认浏览器关闭时销毁)
 - requests.COOKIES.get('键名')                        #获取 
 - response.delete_cookie('键名')                      #删除 Cookie

def set_cookie(requests):
    query_Name = requests.GET.get("username")   
    response =  HttpResponse("set_Cookie")
    response.set_cookie('name',query_Name)
    print(requests.COOKIES['name'])
    return response

-------------------------------------------------------------- 设置Session

 - Django 默认启用 Session
    - 'django.contrib.sessions.middleware.SessionMiddleware' - setting 文件
 - 保存在 服务器 端
 - 直接就加密了
 - 需要依赖于 Cookie(曲奇饼干)

                浏览器        第一次访问没有 Cookie 信息  ->    服务器( 保存数据,生成 Cookie )
                浏览器        返回 Cookie[空],sessionID  <-    服务器( 返回携带 SessionID 的 Cookie 信息 )
                浏览器        请求携带 C包含S 信息        ->   服务器( Session 指向的数据内容 )
                浏览器        请求携带 C包含S 信息        ->   服务器( Session 指向的数据内容 )

requests.session['userID'] = user_id
requests.session['userName'] = userName
requests.session['message'] = "你好, 这是设置了 Session 的 message 内容"

 - 在数据库 Mysql 中 session_key 就是服务器将要发送给浏览器的 Session 凭证, 也就是每次
     - 浏览器访问服务器去携带 Cookie 的时候, 服务器解析 Cookie 中的 Session 凭证, 凭借 session_key 
     - 访问 session_data 中的加密数据, 并将加密数据解析到我们的读取 username = requests.session['user_name'] 中
     - 也就是所谓的数据存储在服务器中
 - 一个浏览器对应一个 SessionID 
 - 实现 Session 的时候, 系统会自动实现 Cookie

-------------------------------------------------------------- 状态保持

1. login()方法介绍
 - 状态保持：
 - 将通过认证的用户的唯一标识信息（比如：用户ID）写入到当前session会话中
    - login()方法：
 - Django用户认证系统提供了 login() 方法
 - 封装了写入session的操作，帮助我们快速实现状态保持
     - login()位置： django.contrib.auth.__init__.py文件中
 - login(request, user)

2. login()方法使用
# 保存注册数据
from django.contrib.auth import login
try:
    user = User.objects.create_user(username=username, password=password, mobile=mobile)
except DatabaseError:
    return http.JsonResponse({'code': 400, 'errmsg': '注册失败!'})

# 实现状态保持
- 这里的 User 应当是一个返回的类
login(request, user)

# 响应注册结果
return http.JsonResponse({'code': 0, 'errmsg': '注册成功!'})

-------------------------------------------------------------- 读取Session

 - user_id = requests.session.get('user_id')
 - username = requests.session.get('user_name')
 - 使用常规读取字典的方式可能会导致报错
    - .get()没有则 None, 不会报错

-------------------------------------------------------------- Session 存储位置更改       

 - 官网: https://django-redis-chs.readthedocs.io/zh_CN/latest/
 - MySQL 终是慢的, 源于硬盘, 那么更换数据库, 大抵 Redis 会更好
     - 正如我门前有两颗树, 一颗是 二叉树, 另一个也是 二叉树

 - 安装扩展 (虚拟) pip install django-redis

在settings.py文件中做如下设置
# Session 保存在 Redis 中
CACHES = {                  
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',         #让 Redis 实现我们的缓存
        'LOCATION': 'redis://127.0.0.1:6379/1',             #IP地址,1号库
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}
SESSION_ENGINE = 'django.contrib.sessions.backends.cache'
SESSION_CACHE_ALIAS = 'default'

-------------------------------------------------------------- Session 相关操作

1） 以键值对的格式写session。
     - request.session['键'] = 值

2）根据键读取值。
     - request.session.get('键',默认值)

3）清除所有 session ，在存储中删除值部分。
     - request.session.clear()

4）清除所有 session 数据，在存储中删除 session 的整条数据。
     - request.session.flush()

5）删除session中的指定键及值，在存储中只删除某个键及对应的值。
     - del request.session['键']

6）设置session的有效期
     - request.session.set_expiry(value)

如果value是一个整数，session将在value秒没有活动后过期。
如果value为0，那么用户session的Cookie将在用户的浏览器关闭时过期。
如果value为None，那么session有效期将采用系统默认值， 默认为两周，可以通过在settings.py中设置SESSION_COOKIE_AGE来设置全局默认值。

-------------------------------------------------------------- 类视图

 - 在Django中也可以使用类来定义一个视图，称为 类视图 
     - 使用类视图可以将视图对应的不同请求方式以类中的不同方法来区别定义

from django.views.generic import View

class RegisterView(View):
    """类视图：处理注册"""

    def get(self, request):
        """处理GET请求，返回注册页面"""
        return render(request, 'register.html')

    def post(self, request):
        """处理POST请求，实现注册逻辑"""
        return HttpResponse('这里实现注册逻辑')

 # - 配置路由时，使用类视图的as_view()方法来添加。

urlpatterns = [
    path('register/', views.RegisterView.as_view()),
]

-------------------------------------------------------------- 多继承和 MRO 排序

# 登陆用户访问, 未登录用户跳转登陆界面
# LoginRequiredMixin 
#    - 判断, 只有登陆用户才可以运行页面 admin 页面
#    - 失败会跳转到系统的 accounts/login 页面

from django.contrib.auth.mixins import LoginRequiredMixin

class login(LoginRequiredMixin, View)

 - MRO 排序
 
        object
           ^
           D   
      ->       <-
    B             C
        <- A ->

 - 实际调用顺序( 查找顺序 )
     - A -> B -> C -> D -> object

 - 所以也就是说 LoginRequiredMixin 与 View 顺序会对代码结果产生影响

-------------------------------------------------------------- 中间件

 - 创建新的文件 名字叫 middleware.py
 - from django.utils.deprecation import MiddlewareMixin
 - 请查询源码, __call__ 方法里面的 if 语句中

class TestMiddleWare(MiddlewareMixin):

    def process_request(self, request):                  # 每次请求之前都会调用执行
        pass

    def process_response(self, request, response):       # 每次响应之前都会调用执行
        ...
        return response

 - 注册中间件

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    # 'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'book.middleware.TestMiddleWare'
]

-------------------------------------------------------------- 中间件执行顺序

 - 在请求视图被处理前, 中间件由上至下执行的        请求

 - 在请求视图被处理后, 中间件由下至上执行的        响应

-------------------------------------------------------------- 常用工程目录结构

 - libs 存放第三方的库文件

 - utils 存放项目自己定义的公共函数或类等

 - apps 存放Django的应用

 - templates 模板文件存放文件夹

-------------------------------------------------------------- 配置 日志 文件 ( 线上排错 )

 - 收集线上的一些问题
 - 记录用户行为
 - 程序根目录准备 logs 文件夹
     - 增加 .gitkeep 文件
 - git 自动忽略 logs 文件

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,  # 是否禁用已经存在的日志器
    'formatters': {  # 日志信息显示的格式
        'verbose': {
            'format': '%(levelname)s %(asctime)s %(module)s %(lineno)d %(message)s'
        },
        'simple': {
            'format': '%(levelname)s %(module)s %(lineno)d %(message)s'
        },
    },
    'filters': {  # 对日志进行过滤
        'require_debug_true': {  # django在debug模式下才输出日志
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    'handlers': {  # 日志处理方法
        'console': {  # 向终端中输出日志
            'level': 'INFO',
            'filters': ['require_debug_true'],
            'class': 'logging.StreamHandler',
            'formatter': 'simple'
        },
        'file': {  # 向文件中输出日志
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': os.path.join(BASE_DIR, 'logs/meiduo.log'),  # 日志文件的位置
            'maxBytes': 300 * 1024 * 1024,
            'backupCount': 10,
            'formatter': 'verbose'
        },
    },
    'loggers': {  # 日志器
        'django': {  # 定义了一个名为django的日志器
            'handlers': ['console', 'file'],  # 可以同时向终端与文件中输出日志
            'propagate': True,  # 是否继续传递日志信息
            'level': 'INFO',  # 日志器接收的最低日志级别
        },
    }
}

-------------------------------------------------------------- 查看 日志 文件

 - 不同的应用程序所定义的日志等级可能会有所差别，分的详细点的会包含以下几个等级：

FATAL/CRITICAL = 重大的，危险的
ERROR = 错误
WARNING = 警告
INFO = 信息
DEBUG = 调试
NOTSET = 没有设置

import logging

# 创建日志记录器
logger = logging.getLogger('django')
# 输出日志
logger.debug('测试logging模块debug')
logger.info('测试logging模块info')
logger.error('测试logging模块error')

-------------------------------------------------------------- 设置访问的域名

 - 不写的话默认 127.0.0.1 
 - 写的话需要写入 127.0.0.1 的
ALLOWED_HOSTS = ['www.meiduo.site','127.0.0.1']

-------------------------------------------------------------- 前端 CORS 跨域问题解决

安装                  pip install django-cors-headers
# 添加应用
INSTALLED_APPS = (
    ...
    'corsheaders',
    ...
)
# 中间层设置 ( 放到最上面 )
MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    ...
]
# 添加白名单
# CORS
CORS_ORIGIN_WHITELIST = (
    'http://127.0.0.1:8080',
    'http://localhost:8080',
    'http://www.meiduo.site:8080',
    'http://www.meiduo.site:8000'
)
CORS_ALLOW_CREDENTIALS = True  # 允许携带cookie

 - 凡是出现在白名单中的域名，都可以访问后端接口
 - CORS_ALLOW_CREDENTIALS 指明在跨域访问中，后端是否支持对cookie的操作。

-------------------------------------------------------------- Django 原生密码加密

 - 使用 create_user 即可
User.objects.create_user(username=username,password=password,mobile=mobile)


-------------------------------------------------------------- 代码连接 redis

 - 链接 redis ( 默认是 default )

from django_redis import get_redis_connection
redis_cli = get_redis_connection('code') <- 选择库,不写默认 default 配置信息

#指令,限时 name , time/秒 , value
redis_cli.setex(Key, 最大生存时间/秒, Value)


-------------------------------------------------------------- HttpResponse - content_type 选项详细化

 - 大类接小类    例子: .text = text/plain
 - 请在网上搜索 MIME 以得以使用
 - return HttpResponse(image, content_type='image/jpeg')

-------------------------------------------------------------- 图片验证码后端逻辑

 - 借助第三方平台进行首发短信
 - 我 没钱 邮箱
 - https://www.yuntongxun.com/
 - 工具包里面以存放文件

 - 流程
  - 获取前端发过来的 image_code 以和 uuid <- image_code是用户输入的图形验证码,uuid 是图片的 redis 库的键 
  - 进行两方的全部非空判断
  - 连接 redis 根据 uuid 以取得值 ( 二进制文件需要解码 ), 判断是否为空( is None )
  - 需要将解码之后的数据库中 密码小写化( .decode().lower() ), 与用户写的验证码小写化进行比对 ( .lower() )
  - 比对成功之后编写接下来的业务逻辑

-------------------------------------------------------------- 避免恶意多次发送短信

 - 根据手机号拼接新字段写入 redis数据库,  send_flag_phoneNumber
     - 限制最大生存时间, 在生存周期之内无法再次发送短信
send_flag = redis.get()
if send_flag is not None:

-------------------------------------------------------------- pipeline 管道技术操作 Redis

 - 目前存在的问题
     - 如果Redis服务端需要同时处理多个请求，加上网络延迟，那么服务端利用率不高，效率降低。
     - 发起一次请求就建立 TCP 连接
 - 解决的办法：
     - 管道pipeline
         - 可以一次性发送多条命令并在执行完后一次性将结果返回。
         - pipeline通过减少客户端与Redis的通信次数来实现降低往返延时时间。
 - 实现的原理
     - 实现的原理是队列。
         - Client可以将三个命令放到一个tcp报文一起发送。
         - Server则可以将三条命令的处理结果放到一个tcp报文返回。
         - 队列是先进先出，这样就保证数据的顺序性。


 - 管道技术
     - 新建管道 pipeline = redis_cli.pipeline()
 - 管道收集指令
     - 将原先 redis_cli 替换为 pipeline
         - pipeline.setex(mobile, 300, sms_code)
         - pipeline.setex(f"send_flag_{mobile}",60,1)
 - 管道执行指令 pipeline.execute()

-------------------------------------------------------------- 生产者消费者模式( 耗时阻塞 )

问题：
 - 我们的代码是自上而下同步执行的。
 - 发送短信是耗时的操作。如果短信被阻塞住，用户响应将会延迟。
 - 响应延迟会造成用户界面的倒计时延迟。

解决：
 - 异步发送短信
 - 发送短信和响应分开执行，将发送短信从主业务中解耦出来。

-------------------------------------------------------------- 生产者消费者方案( 异步方案Celery )

 - 一个简单、灵活且可靠、处理大量消息的分布式系统，可以在一台或者多台机器上运行。
 - Celery是一个功能完备即插即用的任务队列
 - 单个 Celery 进程每分钟可处理数以百万计的任务。
 - 通过消息进行通信，使用消息队列（broker）在客户端和消费者之间进行协调。

-------------------------------------------------------------- Celery 实现异步发送

 - 在根目录创建单独的文件夹 celery_tasks
 - 内部存放文件 main.py  config.py  [名字]文件夹(专门存放 tasks.py 文件)

 - 在 main 文件中写入
 from celery import Celery

 # 为celery使用django配置文件进行设置
 import os
 os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'meiduo_mall.settings')

 # 创建celery实例  设置名字(这里就写路径吧)
 celery_app = Celery('celery_tasks')

 # 设置 broker 也就是队列的指定
 # 通过加载配置文件设置        路径
 app.config_from_object('celery_tasks.config')

 # 开始执行,添加生产者       路径, 自动检测 tasks 文件
 app.autodiscover_tasks(['celery_tasks.sms'])


 - 在 config 文件中写入
 #我们指定 redis 作为我们的队列        15号库
 broker_url = "redis://127.0.0.1:6379/15"


 - 在 [名字]文件夹(专门存放 tasks.py 文件) 文件里放入
     - 导包 将上面的 celery_app 变量导入进来, 需要它作为装饰器
     - 生产者
 from celery_tasks.main import app
 @app.task
 def celery_send_sms_code(mobie,code):
    CCP().send_template_sms(mobie, [f'{code}', 5], 1)


 - 开启 celery ( 消费者准备 )
 - 跑到跟文件
 celery -A celery_tasks.main worker -l info   (虚拟环境使用)
    1. -A 指对应的应用程序, 其参数是项目中 Celery 实例的位置。
    2. worker 指这里要启动的 worker。
    3. -l 指日志等级，比如info等级。


 - 补充：celery worker工作模式
     - celery 高版本不兼容 windows 因此需要pip install eventlet来兼容windows
celery -A celery_tasks.main worker -l info -P eventlet -c 1000 #将进程改变为协程





 - 一切准备完毕之后理所当然的应当要添加任务了
 - 请将之前需要分开的同步代码改为
 from celery_tasks.sms.tasks import celery_send_sms_code
 # 添加任务 - 执行参数
 celery_send_sms_code.delay(mobile,sms_code)



1. main.py 配置 - config 解耦
2. [名字]文件夹(专门存放 tasks.py 文件) 这里是生产者的 业务逻辑 (没有使用)
3. 指令就是 使用配置文件redis队列 消费生产的代码 
4. 同步文件 修改独立化 添加生产者( 使用 )

生产 - redis作为队列 - 消费(芹菜执行)

5. 补充celery worker的工作模式
 - 默认是进程池方式，进程数以当前机器的CPU核数为参考，每个CPU开四个进程。
 - 如何自己指定进程数： celery worker -A proj --concurrency=4
 - 如何改变进程池方式为协程方式： celery worker -A proj --concurrency=1000 -P eventlet -c 1000
 - # 安装eventlet模块
 - $ pip install eventlet

 - # 启用 Eventlet 池
 - $ celery -A celery_tasks.main worker -l info -P eventlet -c 1000

-------------------------------------------------------------- 登陆(两个都检查)

 - 判断用户输入的是用户名还是电话号码
 - User.USERNAME_FIELD="mobile"/"username"(默认)                   设置查询字段
 - from django.contrib.auth import authenticate                    导入 Django 的自带验证库, 因为加密也是他加的
user = authenticate(username=username,password=password)           提供的查询方式(上方可以设置)
    if user is None:                                               没有查到或密码不对就返回 
        return JsonResponse({'code':400,'errmsg':'账号或密码错误'}) 

    from django.contrib.auth import login                           导入 Django 自带的状态保持库
    login(requests,user)
    if remembered:                                                  前端选择是否记住密码
        requests.session.set_expiry(None)                           设置时间
    else:
        requests.session.set_expiry(0)


-------------------------------------------------------------- LoginRequiredMixin 猜测的登陆判断逻辑

 - 先导入
 - 继承
 - 点进去发现 LoginRequiredMixin 继承自 AccessMixin
 - 而 LoginRequiredMixin 的判断是 if not request.user.is_authenticated:
     - request.user.is_authenticated:
         - 据我打印发现 request.user 其实就是指向 浏览器的 Session 凭证的
         - 凭证 去 找数据库的内容，找到了就是登陆了
         - 因为一旦删除该凭证则无法认为已登陆
         - user.is_authenticated = 用户是否登陆

-------------------------------------------------------------- 对于 ORM 的类进行基类定义

from django.db import models

class BaseModel(models.Model):
    """为模型类补充字段"""

    create_time = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    update_time = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        abstract = True  # 说明是抽象模型类, 用于继承使用，数据库迁移时不会创建BaseModel的表


# class create_user_QQ(BaseModel) ...

-------------------------------------------------------------- 协助 QQ 登陆的库 QQLoginTool

1. QQLoginTool介绍
 - 该工具封装了对接QQ互联的请求操作。
 - 可用于快速实现QQ登录的一种工具包。
2. QQLoginTool安装
 - pip install QQLoginTool
3. QQLoginTool使用说明
     - 导入
         - from QQLoginTool.QQtool import OAuthQQ
     - 初始化OAuthQQ对象
         - oauth = OAuthQQ(client_id=settings.QQ_CLIENT_ID,         appid
            client_secret=settings.QQ_CLIENT_SECRET,                appsecret
            redirect_uri=settings.QQ_REDIRECT_URI,                  用户同意登陆之后, 跳转的页面
            state=next)                                             未知
     - 获取QQ登录扫码页面，扫码后得到Authorization Code
         - login_url = oauth.get_qq_url()
     - 通过Authorization Code获取Access Token
         - access_token = oauth.get_access_token(code)
     - 通过Access Token获取OpenID
         - openid = oauth.get_open_id(access_token)

-------------------------------------------------------------- 检查密码(单一检查)

对于 user = User.objects.create_user(username=mobile,mobile=mobile,password=password) 的检测密码
     - 由于密码加密, 所以我们仍然需要 Django 的方法解密
user.check_password(password)    

 - 一个是两个都检查, 一个是单一检查

-------------------------------------------------------------- 对于敏感数据的加密 - Authlib HS256( 例如 openid )

- https://docs.authlib.org/en/latest/basic/install.html 请查看官当文档

from authlib.jose import jwt

1. 使用方式一 (不安全, 简单)                                          这里是单独测试环境
from authlib.jose import jwt
header = {'alg': 'HS256'}
payload = {'iss': 'Authlib', 'sub': '123', 'name': 'bob'}
secret = '123abc.'
token = jwt.encode(header, payload, secret)
detoken = jwt.decode(token,secret)
print(token)
print(detoken)

-------------------------------------------------------------- 对于敏感数据的加密 - Authlib RSA256( 例如 openid )
pip install pycryptodome

1. 使用非对称密钥加密 (安全, 难欸)
 - 找不到模块情况下 windows环境下安装完pycryptodome后在你python的根目录下如: "Python/Python36/Lib/site-packages"
    - 里面有一个文件夹叫做 crypto,将首字母小写c改成大写C即可解决
    - 公钥加密的信息，只有私钥才能解密

2.先单独创建一个文件, 用于生成私钥与公钥, 然后文件中写入 (这里代码压了一下)
    """
    from Crypto.PublicKey import RSA   from Crypto import Random
    def main():random_generator = Random.new().read         rsa = RSA.generate(2048, random_generator)
    # 私钥private_pem = rsa.exportKey()       with open("private.pem", "wb") as f:
    f.write(private_pem)# 公钥public_pem = rsa.publickey().exportKey()
    with open("public.pem", "wb") as f:     f.write(public_pem)
    if __name__ == '__main__':main()
    """

3.完成之后会多出 private.pem (私钥) 与 public.pem (公钥) 文件


{
    username:"Monika",              HS256
    age:"18",                       HS256
    userBackground:'imagePath'      HS256
    permissions:"root",             HS256
    key:"123456"                    RSA
}


hs256加密所有数据, rsa256 加密密钥传输

-------------------------------------------------------------- 参数 request 详细解释

 - 来自中间件 'django.contrib.auth.middleware.AuthenticationMiddleware'
 - 一开始去寻找 session 信息, 没找到就返回匿名用户
     - 作为中间件, 他会重复查找, 找到之后会获取 session 所对应的信息
 - request 是一个大对象, 
     - .user                    包含用户的所有在数据库中的信息 ( 用户的示例对象, 可以直接修改值, 数据库也会改变, 下文 )
     - .COOKIES                 存储浏览器 cookie 所有信息, username/sessionid
     - .is_authenticated        判断用户登陆状态 LoginRequiredJSONMixin 的判断逻辑

-------------------------------------------------------------- 对于 数据库 修改的便捷方式

 - 在登陆的状态下, 也就是需要 LoginRequiredJSONMixin 加入
 
class EmailView(LoginRequiredJSONMixin,View):
    def put(self, requests):
        data = JSON.loads(requests.body.decode())
        email = data.get('email')
        user = requests.user
        user.email = email
        user.save()

-------------------------------------------------------------- Django 实现发送邮件

 - send_mall()方法介绍
 - 位置： 在django.core.mail模块提供了send_mail()来发送邮件。
 - 方法参数：
     - send_mail(subject, message, from_email, recipient_list, html_message=None)
         - subject 邮件标题
         - message 普通邮件正文，普通字符串
         - from_email 发件人
         - recipient_list 收件人列表
         - html_message 多媒体邮件正文，可以是html字符串
 - 配置邮件服务器
     - EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'        # 让 Django 那个库发送邮件
     - EMAIL_HOST = 'smtp.163.com'                                          # 邮件服务器
     - EMAIL_PORT = 25                                                      # 邮件服务器端口
     - EMAIL_HOST_USER = 'monika_dream@163.com'                             # 发送文件的邮箱
     - EMAIL_HOST_PASSWORD = 'JQSNZVNTDYLGQKWC'                             # 授权码
     - EMAIL_FROM = '美多商城<qi_rui_hua@163.com>'                           # 邮件来自  



 - 发送邮件
from django.core.mail import send_mail
subject = "美多商城激活邮件"                            # 标题
message = "永远爱 Monika"                              # 与 html_message 二选一, 后者会将这里覆盖
from_email = "我永远爱Monika<monika_dream@163.com>"    # 发件人
recipient_list = ['1109827629@qq.com']                # 给谁发
html_message = "<h1>扣你吉瓦</h1>"                     # 可以写 html/css 

send_mail(subject,message,from_email,recipient_list,html_message)

配置邮件服务器 那里直接丢到 setting 文件中即可, 无需页面引入

 - 如果要 跳转链接, 必须要为 https 

-------------------------------------------------------------- Django 缓存工具


 - 不是频繁变化的数据，所以没有必要每次都重新查询。
 - 所以我们可以选择对 数据 进行 缓存 处理。
 - 1.缓存工具
 - from django.core.cache import cache
         - 存储缓存数据：cache.set('key', 内容, 有效期/秒)
         - 读取缓存数据：cache.get('key')
         - 删除缓存数据：cache.delete('key')
 - 注意：存储进去和读取出来的数据类型相同，所以读取出来后可以直接使用。

 - 2.缓存逻辑
                有        返回缓存数据
拿   缓存数据
                没有      查询数据           存储缓存数据

from django.core.cache import cache
class SubAreaView(View):
    def get(self, requests, id):
        data_list = cache.get('province')
        # 没有缓存数据就查询数据并且设置缓存
        if data_list is None:
            up_level = Area.objects.get(id=id)
            down_level = up_level.subs.all()
            data_list=[]
            for item in down_level:
                data_list.append({
                    'id': item.id,
                    'name': item.name
                })
            cache.set('province',data_list,24*3600)


        return JsonResponse({'code': 0, 'errmsg': 'ok', 'sub_data': {'subs': data_list}})

 - 缓存走的是 setting 文件中的 CACHES 配置项中的 default 配置, 我这里走的是 redis


-------------------------------------------------------------- MinIO 工具

 - 用 go 语言编写的一款开源的轻量级分布式文件系统。
 - 功能包括：
     - 文件存储、文件访问（文件上传、文件下载）、文件同步等，
     - 解决了大容量存储和负载均衡的问题。
     - 特别适合以文件为载体的在线服务，如相册网站、视频网站等等。
 - 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标。
 - 可以帮助我们搭建一套高性能的文件服务器集群，并提供文件上传、下载等服务。

-------------------------------------------------------------- Docker介绍

 - Docker中文社区文档
 - Docker 是一个开源的软件部署解决方案。
 - Docker 也是轻量级的应用容器框架。
 - Docker 可以打包、发布、运行任何的应用。
 - Docker 就像一个盒子，里面可以装很多物件，
     - 如果需要某些物件，可以直接将该盒子拿走，而不需要从该盒子中一件一件的取。
 - Docker 是一个客户端-服务端(C/S)架构程序。
 - 客户端只需要向服务端发出请求，服务端处理完请求后会返回结果。


 - 镜像（Image）
     - Docker的镜像概念类似于虚拟机里的镜像，是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。
     - 例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了MySQL或用户需要的其它应用程序。

 - 容器（Container）
     - Docker容器是由Docker镜像创建的运行实例，类似VM虚拟机，支持启动，停止，删除等。
         - 每个容器间是相互隔离的，容器中会运行特定的应用，包含特定应用的代码及所需的依赖文件。
         - 没有界面的虚拟机, 运行在虚拟环境中的项目

 - 仓库（Repository）
     - Docker的仓库功能类似于Github，是用于托管镜像的。

-------------------------------------------------------------- python 连接 MinIO 方式

.minio.sys/config/config.json/里面的文件就是了, 但是你可以在创建的时候就修改密码啊

pip install minio

from minio import Minio
from minio.error import S3Error


minioClient = Minio('127.0.0.1:9000',access_key="minioadmin",secret_key="minioadmin",secure=False)

secure = 设为True代表启用HTTPS。 (默认是True)。 设置为 True 现在会报错 ? 


try:
    minioClient.fput_object('imagessss',"JustMonika.jpg",'./monika.png')        #添加图片
    minioClient.make_bucket("monika")                                           #创建桶, 注意命名规则
    buckets1 , buckets2 = bucketList = minioClient.list_buckets()               #查看所有桶, 返回 list
             # - buckets1.creation_date     创建时间
             # - buckets1.name              名字
    minioClient.bucket_exists('monika')                                         #检查是否已经有了这个桶
    minioClient.remove_bucket('images')                                         #删除这个桶
    re_obj = minioClient.list_objects('images', prefix=None, recursive=False)   #返回数组里包对象, 遍历这个桶
             # - prefix 过滤对象桶的前缀
             # - recursive True代表递归查找，False代表类似文件夹查找，以'/'分隔，不查子文件夹。（可选，默认值是False）。
                    # re_obj.bucket_name string  对象所在存储桶的名称。
                    # re_obj.object_name string  对象的名称。
                    # re_obj.is_dir      bool  True代表列举的对象是文件夹（对象前缀）， False与之相反。
                    # re_obj.size        int  对象的大小。
#---之后不在此过多赘述, 请去 http://docs.minio.org.cn/docs/master/python-client-api-reference 查看
             #list_incomplete_uploads(bucket_name, prefix, recursive=False)     #列出存储桶中未完整上传的对象。
            get_object(存储桶名称。, 对象名称, request_headers=None )                                #下载一个对象。
            get_partial_object(bucket_name, object_name, offset=0, length=0, request_headers=None) #下载一个对象的指定区间的字节数组。
            fget_object(bucket_name, object_name, file_path, request_headers=None)                 #下载并将文件保存到本地。
            copy_object(查文档)                #拷贝对象存储服务上的源对象到一个新对象
            put_object(查文档)                 #添加一个新的对象到对象存储服务。
            stat_object(查文档)                #获取对象的元数据。
            remove_object(查文档)              #删除一个对象。
            remove_objects(查文档)             #删除存储桶中的多个对象。
            fput_object(查文档)                #通过文件上传到对象中。
            remove_incomplete_upload(查文档)   #删除一个未完整上传的对象。
except S3Error:
    print("没有桶啊")

-------------------------------------------------------------- collections 库介绍

Python内置的数据类型和方法，
collections模块在这些内置类型的基础提供了额外的高性能数据类型，
比如基础的字典是不支持顺序的，collections模块的OrderedDict类构建的字典可以支持顺序，
collections模块的这些扩展的类用处非常大

https://docs.python.org/zh-cn/3/library/collections.html#module-collections


from collections import OrderedDict
具有顺序的字典

-------------------------------------------------------------- Elasticsearch 搜索
 - 数据库 like 查询效率太低

 - 实现全文检索的搜索引擎，首选的是Elasticsearch。
 - Elasticsearch是用 Java 实现的，开源的搜索引擎。
 - 它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github等都采用它。
    - Elasticsearch 的底层是开源库Lucene 。但是，没法直接使用 Lucene，必须自己写代码去调用它的接口。
 - 分词说明
     - 搜索引擎在对数据构建索引时，需要进行分词处理。
     - 分词是指将一句话拆解成多个单字或词，这些字或词便是这句话的关键词。
     - 比如：我是中国人
     - 分词后：我、是、中、国、人、中国等等都可以是这句话的关键字。
 - Elasticsearch 不支持对中文进行分词建立索引
 - 需要配合扩展elasticsearch-analysis-ik来实现中文分词处理。

搜索引擎进行全文检索时，会对数据库中的数据进行一遍预处理，单独建立起一份索引结构数据。
索引结构数据类似新华字典的索引检索页，里面包含了关键词与词条的对应关系，并记录词条的位置。
搜索引擎进行全文检索时，将关键字在索引数据中进行快速对比查找，进而找到数据的真实存储位置。

-------------------------------------------------------------- Haystack 扩展建立索引

 - Haystack 是在Django中对接搜索引擎的框架，搭建了用户和搜索引擎之间的沟通桥梁。
 - 我们在Django中可以通过使用 Haystack 来调用 Elasticsearch 搜索引擎。
 - Haystack 可以在不修改代码的情况下使用不同的搜索后端（比如Elasticsearch、Whoosh、Solr等等）。

pip install "django-haystack[elasticsearch]"

与大多数 Django 应用程序一样，您应该将 Haystack 添加到您的设置文件中（通常）。

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',

    # Added.
    'haystack',

    # Then your usual apps...
    'blog',
]

#setting 中写入

HAYSTACK_CONNECTIONS = {
    'default': {
        'ENGINE': 'haystack.backends.elasticsearch7_backend.Elasticsearch7SearchEngine',
        'URL': 'http://127.0.0.1:9200/',    #请查看 ES config 中的配置方案
        'INDEX_NAME': 'haystack',           #索引名字, 随便起
    },
}

 - 请在需要检索的子应用下面去创建一个 search_indexes.py 文件( 他会自动搜索 )
 - 针对于去搜索什么什么则需要去针对于创建一个类

import datetime
from haystack import indexes
from myapp.models import Note


class NoteIndex(indexes.SearchIndex, indexes.Indexable): 
#每个都需要有一个（并且只能有一个）document=True 的字段。
    #这向 Haystack 和搜索引擎表明 哪个字段是在其中搜索的主要字段,说白就是在整个搜索过程中的权重比较高
    #字段名起什么都可以, text 只是惯例
    #所有的索引的 这个字段都一致就行
#use_template=True 允许我们单独设置一个文件来设置哪些字段需要检索
    #创建的方案, 在根目录下创建 templates/search/indexes/子应用名目录/模型类名小写_text.txt
    # {{object.name}}  {{object.caption}}  {{object.id}}
    text = indexes.CharField(document=True, use_template=True)


    def get_model(self):
        return SKU

    def index_queryset(self, using=None):
        """Used when the entire index for model is updated."""
        return self.get_model().objects.all()   #这里根据具体需求


 - 运行
./manage.py rebuild_index
没什么提示?


-------------------------------------------------------------- Haystack 搜索

 - 因为我们是借助于 haystack 来对接 ES(已经对于数据建立索引) 来查找数据
 - 所以 haystack 可以帮助我们查询数据
 - def create_response(self) 我们需要重写这个方法, 因为它是 render

from haystack.views import SearchView
class SKUSearchView(SearchView):
    def create_response(self):
        context = self.get_context()  # 搜索的结果
        sku_list = []                   #构建列表
        for sku in context['page'].object_list:
            sku_list.append({
                ...
            })
        return JsonResponse(sku_list,safe=False)


 - 然后在 url 中直接实例化即可
 path("search/", SKUSearchView())



 - 查询的底层内容
def get_query(self):                    #前端注意传参方式是 query 传参, 且参数为 q=?
    self.form.cleaned_data["q"]

def build_page(self):                   #这是分页底层逻辑

#前端方案 query 传参[GET]
q: huawei       
page: 2
page_size: 2  ? 这个存疑, 或许没必要传

 - 设置搜索每页返回的记录条数
    在 setting 文件中写入即可
    HAYSTACK_SEARCH_RESULTS_PER_PAGE = 5


-------------------------------------------------------------- 页面静态化

1.为什么要做页面静态化
 - 减少数据库查询次数。
 - 提升页面响应效率。

2.什么是页面静态化
 - 将动态渲染生成的页面结果保存成html文件，放到静态文件服务器中。
 - 用户直接去静态服务器，访问处理好的静态html文件。

3.页面静态化注意点
 - 用户相关数据不能静态化：
     - 用户名、购物车等不能静态化。
 - 动态变化的数据不能静态化：
     - 热销排行、新品推荐、分页排序数据等等。
 - 不能静态化的数据处理：
     - 可以在用户得到页面后，在页面中向后端发送Ajax请求获取相关数据。
     - 直接使用模板渲染出来。
     - 其他合理的处理方式等等。


 - 说白就是偷梁换柱
 - 这种一般都是最后的性能优化方案
 - 后端将大至不变的数据渲染到页面上
 - 替换前端要请求的内容, 再把前端文件替换
     - 直接函数就可以了, 替换的时候命令行运行就可以了 python manage.py shell
     - 导入文件, 运行函数
 - 在 根文件夹中需要有 templantes
 - 下面是流程
def generic_meiduo_index():
    print("--------------------------")

    # 我们的首页 后边会讲解页面静态化
    # 我们把数据 传递 给 模板
    context = {
        'categories': categories,
        'contents': contents,
    }
    #加载渲染的模板
    from django.template import loader
    index_template = loader.get_template('index.html')
    #把数据给模板
    index_html_data = index_template.render(context)
    #把渲染好的 HTML 放到指定文件中去
    from meiduo_mall import settings
    import os

    file_path = os.path.join(os.path.dirname(settings.BASE_DIR),'front_end_pc/index.html')
    with open(file_path,'w',encoding='utf-8') as f:
        f.write(index_html_data) 


-------------------------------------------------------------- 定时任务 crontab 静态化首页(windows 无法使用)

 - 可以使用 celery 的定时任务

 - 对于首页的静态化，考虑到页面的数据可能由多名运营人员维护，并且经常变动，
     - 所以将其做成定时任务，即定时执行静态化。
 - 在Django执行定时任务，可以通过 django-crontab 扩展来实现。

 - 1.安装 django-crontab          pip install django-crontab

 - 2.注册 django-crontab 应用
    INSTALLED_APPS = [    
        'django_crontab', # 定时任务
    ]

 - 3.设置定时任务

     - 定时时间基本格式 :  *  *  *  *  *

        分 时 日 月 周    命令

        M: 分钟（0-59）。每分钟用 * 或者 */1 表示
        H：小时（0-23）。（0表示0点）
        D：天（1-31）。
        m: 月（1-12）。
        d: 一星期内的天（0~6，0为星期天）。

     - 定时任务分为三部分定义：

        - 任务时间
        - 任务方法
        - 任务日志

 - settings 中写入
CRONJOBS = [
    # 每1分钟生成一次首页静态文件
    # 分 时 日 月 周    路径.函数名                                       日志文件存放 >> 是必须的
    ('*/1 * * * *', 'apps.contents.crons.generic_meiduo_index', '>> ' + os.path.join(BASE_DIR, 'logs/crontab.log'))
]
解决 crontab 中文问题

在定时任务中，如果出现非英文字符，会出现字符异常错误
CRONTAB_COMMAND_PREFIX = 'LANG_ALL=zh_cn.UTF-8'
4.管理定时任务

# 添加定时任务到系统中

$ python manage.py crontab add


# 显示已激活的定时任务

$ python manage.py crontab show


# 移除定时任务

$ python manage.py crontab remove

解决 ModuleNotFoundError: No module named 'fcntl'
     - C:/Users/Lenovo/Desktop/mido-mall-git42/meiduo_center/Lib/site-packages
     - 添加 fcntl.py 文件
     - 写入:
def fcntl(fd, op, arg=0):
    return 0
def ioctl(fd, op, arg=0, mutable_flag=True):
    if mutable_flag:
        return 0
    else:
        return ""
def flock(fd, op):
    return
def lockf(fd, operation, length=0, start=0, whence=0):
    return     

-------------------------------------------------------------- 字典转 二进制模块

 - pickle模块介绍
 - pickle模块是Python的标准模块，提供了对Python数据的序列化操作，
     - 可以将数据转换为bytes类型，且序列化速度快。
 - pickle模块使用：
 - pickle.dumps()   将Python数据序列化为bytes类型数据。
 - pickle.loads()   将bytes类型数据反序列化为python数据。


import pickle

 - dict = {'1': {'count': 10, 'selected': True}, '2': {'count': 20, 'selected': False}}
 - ret = pickle.dumps(dict)
         - b'\x80\x03}q\x00(X\x01\x00\x0 ... tedq\x04\x88x04\x89uu.'
 - pickle.loads(ret)
         - {'1': {'count': 10, 'selected': True}, '2': {'count': 20, 'selected': False}}


 - 提示：pickle模块序列化转换后的数据是bytes类型，浏览器cookie无法存储。
 - base64模块是Python的标准模块，可以对bytes类型数据进行编码，并得到bytes类型的密文数据。
 - base64模块使用：
     - base64.b64encode()   将bytes类型数据进行base64编码，返回编码后的bytes类型数据。
     - base64.b64deocde()   将base64编码后的bytes类型数据进行解码，返回解码后的bytes类型数据。


 - import base64
 - ret = b'\x80\x03}q\x00(X\x01 ... tedq\x04x04\x89uu.'
 - b = base64.b64encode(ret)
 - b = b'gAN9cQAoWAE ... Il1dS4='
 - base64.b64decode(b)
 - b = b'selectedq\x04\x88uX ... q\x05}q\x06(h\x03K\x14h\x04\x89uu.'

 - 如果设置 cookie 需要做一个转换
     - b.decode()

-------------------------------------------------------------- Django-MySQL 事务锁

 - 针对多表修改时, 要么一起成功, 要么一起失败的情况下
 - Django中对于数据库的事务，默认每执行一句数据库操作，便会自动提交。
     - 所以我们需要在保存订单中自己控制数据库事务的执行流程。

 - 在Django中可以通过django.db.transaction模块提供的atomic来定义一个事务。

 - atomic提供两种方案实现事务：

     - 装饰器用法：
from django.db import transaction
@transaction.atomic
def viewfunc(request):
  # 这些代码会在一个事务中执行
  ......

     - with语句用法：
from django.db import transaction
def viewfunc(request):
  # 这部分代码不在事务中，会被Django自动提交
  ......
  with transaction.atomic():
      # 这部分代码会在事务中执行
      ......

 - 装饰器用法： 整个视图中所有MySQL数据库的操作都看做一个事务，范围太大，不够灵活。而且无法直接作用于类视图。
 - with语句用法： 可以灵活的有选择性的把某些MySQL数据库的操作看做一个事务。而且不用关心视图的类型。

 - 结合考虑后使用 with 语法

 - 在Django中，还提供了保存点的支持，
     - 可以在事务中创建保存点来记录数据的特定状态，
     - 数据库出现错误时，可以回滚到数据保存点的状态。

from django.db import transaction

# 创建保存点
save_id = transaction.savepoint()  
# 回滚到保存点
transaction.savepoint_rollback(save_id)
# 提交从保存点到当前状态的所有数据库事务操作
transaction.savepoint_commit(save_id)

with transaction.atomic():
    # 创建事务保存点
    save_id = transaction.savepoint()
    try:
        ...
    except err:
        #出错就回滚(说实话这里应当时不提交)
        transaction.savepoint_rollback(save_id)
    except Exception as e:
        logger.error(e)
    #正常就提交(上方所有对于数据库修改的操作执行)
    transaction.savepoint_commit(save_id)

-------------------------------------------------------------- 货币类型

from decimal import Decimal  
freight = Decimal('10') <- 货币

-------------------------------------------------------------- 悲观-乐观锁

 - 在多个用户同时发起对同一个商品的下单请求时，先查询商品库存，再修改商品库存，
 - 会出现资源竞争问题，导致库存的最终结果出现异常。

 - 悲观锁
     - 当查询某条记录时，即让数据库为该记录加锁，锁住记录后别人无法操作，使用类似如下语法
     - select stock from tb_sku where id=1 for update;
     - SKU.objects.select_for_update().get(id=1)
     - 悲观锁类似于我们在多线程资源竞争时添加的互斥锁，容易出现死锁现象，采用不多。

 - 乐观锁
     - 先记录某一个数据, 在更新的时候, 比对一下这个记录对不对
     - 乐观锁并不是真实存在的锁，而是在更新的时候判断此时的库存是否是之前查询出的库存，
     - 如果相同，表示没人修改，可以更新库存，否则表示别人抢过资源，不再执行库存更新。类似如下操作
     - update tb_sku set stock=2 where id=1 and stock=7;
     - SKU.objects.filter(id=1, stock=7).update(stock=2)
例子:
old_data = sku.stock 
new_stock = sku.stock - count
new_sales = sku.sales + count

result = SKU.objects.filter(id=sku_id, stock=old_data).update(stock=new_stock, sales=new_sales)
if result == 0:
    return JsonResponse({"code":400,"errmsg":"下单失败"})





 - 任务队列
     - 将下单的逻辑放到任务队列中（如celery），将并行转为串行，所有人排队下单。
     - 比如开启只有一个进程的Celery，一个订单一个订单的处理。

-------------------------------------------------------------- MySQL事务隔离级别

1. MySQL事务隔离级别
     - 事务隔离级别指的是在处理同一个数据的多个事务中，一个事务修改数据后，其他事务何时能看到修改后的结果。
     - MySQL数据库事务隔离级别主要有四种：

        1 - Serializable：串行化，一个事务一个事务的执行。

        2 - Repeatable read：可重复读，无论其他事务是否修改并提交了数据，在这个事务中看到的数据值始终不受其他事务影响。

        3 - Read committed：读取已提交，其他事务提交了对数据的修改后，本事务就能读取到修改后的数据值。

        4 - Read uncommitted：读取未提交，其他事务只要修改了数据，即使未提交，本事务也能看到修改后的数据值。

     - MySQL数据库默认使用可重复读（ Repeatable read）。
         - 使用乐观锁的时候，如果一个事务修改了库存并提交了事务，
             - 那其他的事务应该可以读取到修改后的数据值，所以不能使用可重复读的隔离级别，
             - 应该修改为读取已提交（Read committed）。

修改方式：

sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf


transaction-isolation=READ-COMMITTED



修改完成之后重启
sudo service mysql restart



#查看当前隔离级别
mysql> SELECT @@GLOBAL.transaction_isolation;
+--------------------------------+
| @@GLOBAL.transaction_isolation |
+--------------------------------+
| REPEATABLE-READ                |
+--------------------------------+
1 row in set (0.00 sec)

#设置个隔离级别为RC
mysql> set global transaction isolation level READ COMMITTED;
Query OK, 0 rows affected (0.00 sec)

#再次查看隔离级别，设置成功   **注意要新开会话再查看**
mysql> SELECT @@GLOBAL.transaction_isolation;
+--------------------------------+
| @@GLOBAL.transaction_isolation |
+--------------------------------+
| READ-COMMITTED                 |
+--------------------------------+

-------------------------------------------------------------- Mysql主从配置成功后使用

 - 现在是 幻想时间 !

DATABASES = {
    'default': { # 写（主机）
        'ENGINE': 'django.db.backends.mysql', # 数据库引擎
        'HOST': '192.168.103.158', # 数据库主机
        'PORT': 3306, # 数据库端口
        'USER': 'itcast', # 数据库用户名
        'PASSWORD': '123456', # 数据库用户密码
        'NAME': 'meiduo_mall' # 数据库名字
    },
    'slave': { # 读（从机）
        'ENGINE': 'django.db.backends.mysql',
        'HOST': '192.168.103.158',
        'PORT': 8306,
        'USER': 'root',
        'PASSWORD': 'mysql',
        'NAME': 'meiduo_mall'
    }
}


 - 1.创建数据库读写路由
     - 在utils.db_router.py中实现读写路由

class MasterSlaveDBRouter(object):
    """数据库读写路由"""

    def db_for_read(self, model, **hints):
        """读"""
        return "slave"

    def db_for_write(self, model, **hints):
        """写"""
        return "default"

    def allow_relation(self, obj1, obj2, **hints):
        """是否运行关联操作"""
        return True

 - 2.配置数据库读写路由

DATABASE_ROUTERS = ['utils.db_router.MasterSlaveDBRouter']

-------------------------------------------------------------- uWSGI 运行美多商城

 - windows 无法使用, 请到 ubuntu 下使用

 - Django的程序通常使用uwsgi服务器来运行。
     - pip install uwsgi

 - 在根目录下面新建文件叫 uwsgi.ini

[uwsgi]
# 使用Nginx连接时使用，Django程序所在服务器地址
#socket=172.16.21.25:8001
# 直接做web服务器使用，Django程序所在服务器地址
http=172.16.21.25:8001
# 项目目录 - 到 Base DIR 下的 绝对路径
chdir=项目路径/meiduo_project/meiduo_mall
# 项目中wsgi.py文件的目录，相对于项目目录
wsgi-file=meiduo_mall/wsgi.py
# 进程数
processes=4
# 线程数
threads=2
# uwsgi服务器的角色
master=True
# 存放进程编号的文件
pidfile=uwsgi.pid
# 日志文件
daemonize=uwsgi.log
# 指定依赖的虚拟环境
virtualenv=虚拟环境路径/.virtualenvs/meiduo_mall

# 开启
uwsgi --ini uwsgi.ini
# 关闭
uwsgi --stop uwsgi.pid


 - 报错:os没有uname()
 - 解决:
     - 定位到uwsgiconfig.py文件中, 首先import platform后, 将os.unam()都改为platform.uname()即可。
os.uname()是不支持windows系统的。platform模块是支持任何系统。

-------------------------------------------------------------- Django REST framework 框架搭建

 - Django REST framework是以Django扩展应用的方式提供的，
     - 所以我们可以直接利用已有的Django环境而无需从新创建。
     - （若没有Django环境，需要先创建环境安装Django）

 - pip install djangorestframework

 - 我们利用在Django框架学习中创建的demo工程，
     - 在settings.py的INSTALLED_APPS中添加 'rest_framework'。

INSTALLED_APPS = [
    ...
    'rest_framework',
]

 - 接下来就可以使用Django REST framework进行开发了。

-------------------------------------------------------------- Serializer 字段和选项

 - Django REST framework中的 Serializer 使用类来定义，
     - 须继承自 rest_framework.serializers.Serializer。

 - 例如，我们已有了一个数据库模型类BookInfo
     - class BookInfo(models.Model):
 - 我们想为这个模型类提供一个序列化器，可以定义如下：
     - from rest_framework import serializers
     - class BookInfoSerializer(serializers.Serializer):

 - 注意：serializer不是只能为数据库模型类定义，也可以为非数据库模型类的数据定义。
     - serializer是独立于数据库之外的存在, 所以请单独创建文件存放

 - 字段名和模型字段一致
 - 字段类型和模型类型一致
    - 请在项目经验中查看

 - 定义好Serializer类后，就可以创建Serializer对象了。
     - Serializer的构造方法为：
     - Serializer(instance=None, data=empty, **kwarg)

 - 用于序列化时，将模型类对象传入instance参数 ( 导进来 )
     - serializer = BookInfoSerializer(instance=book)
     - #或者
     - serializer = BookInfoSerializer(book)
     - serializer.data 即可获取数据
 - 用于反序列化时，将要被反序列化的数据传入data参数
     - serializer = BookInfoSerializer(data={'name':'xxxx','pub_date':'2000-01-10'})


-------------------------------------------------------------- Serializer 常用字段

 - 字段                     字段构造方式
     - BooleanField         BooleanField()

     - NullBooleanField     NullBooleanField()

     - CharField            CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)

     - EmailField           EmailField(max_length=None, min_length=None, allow_blank=False)

     - RegexField           RegexField(regex, max_length=None, min_length=None, allow_blank=False)

     - SlugField            SlugField(maxlength=50, min_length=None, allow_blank=False) 
         - 正则字段，验证正则模式 [a-zA-Z0-9-]+

     - URLField             URLField(max_length=200, min_length=None, allow_blank=False)

     - UUIDField            UUIDField(format='hex_verbose') format: 1)'hex_verbose'如"5ce0e9a5-5ffa-654b-cee0-1238041fb31a" 2）'hex'如"5ce0e9a55ffa654bcee01238041fb31a" 3）'int'- 如:"123456789012312313134124512351145145114" 4）'urn'如:"urn:uuid:5ce0e9a5-5ffa-654b-cee0-1238041fb31a"

     - IPAddressField       IPAddressField(protocol='both', unpack_ipv4=False, **options)

     - IntegerField         IntegerField(max_value=None, min_value=None)

     - FloatField           FloatField(max_value=None, min_value=None)

     - DecimalField         DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None) 
         - max_digits: 最多位数 
         - decimal_palces: 小数点位置

     - DateTimeField        DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None)

     - DateField            DateField(format=api_settings.DATE_FORMAT, input_formats=None)

     - TimeField            TimeField(format=api_settings.TIME_FORMAT, input_formats=None)

     - DurationField        DurationField()

     - ChoiceField          ChoiceField(choices) 
         - choices与Django的用法相同

     - MultipleChoiceField  MultipleChoiceField(choices)

     - FileField            FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)

     - ImageField           ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)

     - ListField            ListField(child=, min_length=None, max_length=None)

     - DictField            DictField(child=)

 - 通用参数：

     - 参数名称                  说明
         - read_only            表明该字段仅用于序列化输出，默认 False
    
         - write_only           表明该字段仅用于反序列化输入，默认 False
    
         - required             表明该字段在反序列化时必须输入，默认 True
    
         - default              反序列化时使用的默认值
    
         - label                用于 HTML 展示 API 页面时，显示的字段名称

         - allow_null           表明该字段是否允许传入 None ,默认是 False

     - 选项参数：
         - 参数名称              作用
    
         - max_length           最大长度
    
         - min_lenght           最小长度
    
         - allow_blank          是否允许为空
    
         - max_value            最大值
    
         - min_value            最小值

-------------------------------------------------------------- Serializer 使用

 - 上方定义好之后, 导入 图书数据序列化器 进 view 文件后即可使用
 - 默认情况下, 我们不能传递查询结果集, 只能单个传递, 也就是 get(id=1)
     - 如果需要传递查询结果集, 需要在创建 Serializer 增加 many=True 参数

from ... import BookInfo
from ... import BookInfoSerializer

 - 查出单个数据时(打印字典数据)
book = BookInfo.objects.get(id=1)
Serializer = BookInfoSerializer(instance=book)
print(Serializer.data)

 - 查出多个数据时(打印带有顺序的字典数据)
book = BookInfo.objects.all()
Serializer = BookInfoSerializer(instance=book, many=True)
print(Serializer.data)

-------------------------------------------------------------- 关联对象嵌套序列化

 - 串行关系
     - 如果需要序列化的数据中包含有其他关联对象，则对关联对象数据的序列化需要指明。
     - 例如
         - 在定义人物数据的序列化器时，外键book（即所属的图书）字段     如何序列化？(如何序列, 并非查找)
         - 在定义人物数据的序列化器时，外键book（即所属的图书）字段     如何序列化？(如何序列, 并非查找)
         - 在定义人物数据的序列化器时，外键book（即所属的图书）字段     如何序列化？(如何序列, 并非查找)                 
     - 我们先定义PeopleInfoSerialzier除外键字段外的其他部分

 - 对于关联字段，可以采用以下几种方式：

1.IntegerField( 如果你使用这个, 那么你要序列化的外键名必须与数据库保持一致 )
 - book_id = serializers.IntegerField(label='书籍id')

2.PrimaryKeyRelatedField(如果你期望的外键数据的 key 是模型字段的名字, 请使用这个, 获取到 id 值)
 - 必须设置一个选项信息, queryset/read_only=True
 - 包含read_only=True参数时，该字段将不能用作反序列化使用
 - 包含 queryset 参数时，需要告诉系统在哪里匹配外键数据
 - queryset:
     - book = serializers.PrimaryKeyRelatedField(label='图书',queryset=BookInfo.objects.all())
 - 包含 read_only=True 参数时，表示我不验证数据了
 - read_only=True
     - book = serializers.PrimaryKeyRelatedField(label='图书',read_only=True)

3.StringRelatedField(外键所关联的外键的信息, 也就是魔术方法 __str__ 返回值)
 - 这里会进行查找, 查找你这个关联到了哪里, 返回那里的 __str__ 数据, 关联的模型中 __str__ 里面的返回数据
 - 此字段将被序列化为关联对象的字符串表示方式（即 __str__ 方法的返回值）
 - 这里的所谓查找 __str__ 仅仅只是为了指向这个模型

4.使用关联对象的序列化器( 这里忘了请看例子 )
 - 需求: 数据获取书籍以及书籍关联的人物
 - 需要在主模型中写入
     - 1.查看从模型中外键定义的方式, 是否有 related_name='people' 字段
     - 2.在转化文件中.py 另起一个类, 用于限制转序列化的从表 
     - 3.主转化类中写入 people = 限制的类名(many=True)
     - 4.返回: [people/键名]:[{子数据1}, {...}, {...}]
 - from book.serializers import BookInfoSerializer                    
     - 5.这里好似就不需要去加上 instance 了                                                              
 - from book.models import BookInfo                                                                                                 
 - book = BookInfo.objects.get(id=1)                                                                                                  
 - s = BookInfoSerializer(book)                                                                                                     
 - s.data

-------------------------------------------------------------- 反序列化使用

 - serializers 中定义的数据类型, 可以帮助我们在反序列化的时候, 验证传入数据的合法性

from book.serializers import BookInfoSerializer

data = {
    'id':100,
    'name':'Python高级',
    'pub_date':'2020-1-1',
    'readcount':100,
    'commentcount':200
}

serializer = BookInfoSerializer(data=data)      data=data 不能省略

#数据是否合理? 返回 True / False
serializer.is_valid()

 - is_valid() 方法还可以在验证失败时抛出异常 serializers.ValidationError，
     - 可以通过传递 raise_exception=True 参数开启，
     - REST framework 接收到此异常，会向前端返回 HTTP 400 Bad Request 响应。

 - 模型字段限制 ( 选项参数使用 )
     - CharField(max_length=10, min_length=5)   中/英 不得少于5, 不得大于10
     - IntegerField(max_value=10, min_value=1)  数字长度

 - 模型字段限制 ( 通用参数使用 )
     - CharField(required=False)                表明该字段可以不传
     - CharField(read_only=True)                表明该字段只在序列化时使用, 反序列化时忽略该字段
     - CharField(write_only=True)               表明该字段只在反序列化时使用, 序列化时忽略该字段

-------------------------------------------------------------- 反序列化使用 ( 单个字段验证 )

 - 上面对于前端的检测还是太过于宽松, 下面就是更加详细化的检测写法

class BookInfoSerializer(serializers.Serializer):
    """图书数据序列化器"""
    id = serializers.IntegerField(label='ID')
    readcount = serializers.IntegerField(label='阅读量')
    people = PeopleInfoSerializer(many=True)
    ... 上方还是正常写入, 对数据进行基本的检测 类型以及限制

    def validate_readcount(self, value):    # validate_要检测的字段名 这里没有提示, 直接写
        # 在这里写更加详细的检测代码, 永远 Just Monika
        在这里如果想要抛出异常请 raise serializers.ValidationError('阅读数量不能为负数')
        return value
    
-------------------------------------------------------------- 反序列化使用 ( 多个字段验证 )

 - 在序列化器中需要同时对多个字段进行比较验证时，可以定义validate方法来验证，如
 - 它这里的验证就是从宽到严

class BookInfoSerializer(serializers.Serializer):
    """图书数据序列化器"""
    id = serializers.IntegerField(label='ID', read_only=True)
    name = serializers.CharField(label='名称', max_length=20)
    pub_date = serializers.DateField(label='发布日期', required=False)
    readcount = serializers.IntegerField(label='阅读量', required=False)
    commentcount = serializers.IntegerField(label='评论量', required=False)

    def validate(self, attrs):
        readcount = attrs['readcount']
        commentcount = attrs.get('commentcount')
        if commentcount > readcount:
            raise serializers.ValidationError('评论量不能大于阅读量')
        return attrs                   

-------------------------------------------------------------- 反序列化的保存

 - 一切都成功之后, 我们将保存数据
     - 想要基于 validated_data 完成数据对象的创建，
     - 可以通过实现 create() 和 update() 两个方法来实现。

 - 如果你的序列化器继承自 Serializer ,当调用 save() 方法时
     - 需要你自己去反序列化器那里实现 create() 方法

class BookInfoSerializer(serializers.Serializer):
    """图书数据序列化器"""
    id = serializers.IntegerField(label='ID', read_only=True)
    ...
    def create(self, validated_data):
        """ validated_data 验证没有问题的数据 """
        return BookInfo.objects.create(**validated_data)

     def update(self, instance, validated_data):
        """更新，instance为要更新的对象实例"""
        # 如果 validated_data.get 没值, 则用 instance.name 的值 <- 第二个值的作用
        instance.name = validated_data.get('name', instance.name)
        ...
        instance.save()
        return instance

 - 实现了上述方法后，在反序列化数据的时候，就可以通过 save() 方法返回一个数据对象实例了
book=BookInfo.objects.get(id=1)
s = BookInfoSerializer(book)
book = s.save()

 - 如果创建序列化器对象的时候，只传递了 data ，则调用 save() 方法的时候，create()被调用。

 - 如果创建序列化器对象的时候，即创建了 instance 又传递了 data
     - 则调用 save() 方法的时候，系统会认为我们在修改 ( 更新数据 )
     - 所以调用 update() 方法

 - 在对序列化器进行 save() 保存时，可以额外传递数据，
     - 这些数据可以在 create() 和 update() 中的 validated_data 参数获取到
serializer.save(user=request.user)

 - 默认序列化器必须传递所有 required 的字段，否则会抛出验证异常。
     - 但是我们可以使用 partial 参数来允许部分字段更新
serializer = BookInfoSerializer(instance=book, data={'pub_date': '2999-1-1'}, partial=True)



 - 保存之前必须验证
serializers = BookInfoSerializer(data=data)
serializers.is_valid(raise_exception=True)
serializers.save()

-------------------------------------------------------------- 模型类序列化器 ModelSerializer

 - 如果我们想要使用序列化器对应的是Django的模型类，
     - DRF为我们提供了ModelSerializer模型类序列化器来帮助我们快速创建一个Serializer类。
 - ModelSerializer与常规的Serializer相同，但提供了：
 - 基于模型类自动生成一系列字段
 - 包含默认的 create() 和 update() 的实现
 - 我们可以在python manage.py shell中查看自动生成的BookInfoModelSerializer的具体实现
     - from book.serializers import BookInfoModelSerializer
     - BookInfoModelSerializer()


from rest_framework import serializers
from book.models import BookInfo

class BookInfoModelSerializer(serializers.ModelSerializer):
#方式一
    class Meta:
        model = BookInfo
        fields = '__all__'                                          
#方式二
    class Meta:
        model = BookInfo
        exclude = ('image',)
#方式三
    class Meta:
        model = BookInfo
        fields = ('id','name', 'readcount', 'commentcount') // 元组或者列表都可以 ['id','name']
#方式四
    class Meta:
        model = BookInfo
        fields = ('id','name', 'readcount', 'commentcount')
        read_only_fields = ('id', 'readcount', 'commentcount')
#方式五
    class Meta:
        model = BookInfo
        fields = ('id','name', 'readcount', 'commentcount')
        read_only_fields = ('id', 'readcount', 'commentcount')
        extra_kwargs = {
            'readcount': {'min_value': 0, 'required': True},
            'commentcount': {'max_value': 0, 'required': True},
        }
--------------------------------------
 - model 指明参照哪个模型类
 - fields 指明为模型类的哪些字段生成
--------------------------------------
 - 使用 fields 来明确字段，__all__ 表名包含所有字段                             方式一
--------------------------------------
 - 使用 exclude 可以明确排除掉哪些字段                                         方式二
--------------------------------------
 - 显示指明字段                                                               方式三
--------------------------------------
 - 可以通过 read_only_fields 指明只读字段，即仅用于序列化输出的字段              方式四
--------------------------------------
 - 我们可以使用 extra_kwargs 参数为 ModelSerializer 添加或修改原有的选项参数     方式五
--------------------------------------
 - 方式一与方式二必须择其一
 - 如果你在类中定义了字段, 必须添加进 fields 里面 - 注意()

-------------------------------------------------------------- APIView


 - APIView 是 REST framework 提供的所有视图的基类，继承自 Django 的 View 父类。
 - APIView与View的不同之处在于：
     - 传入到视图方法中的是REST framework的Request对象，而不是Django的HttpRequeset对象；
     - 视图方法可以返回REST framework的Response对象，视图会为响应数据设置（render）符合前端要求的格式；
     - 任何APIException异常都会被捕获到，并且处理成合适的响应信息；
     - 在进行 dispatch() 分发前，会对请求进行身份认证、权限检查、流量控制。
 - 记得 settings 要注册 'rest_framework' 写在哪里都可以
 - 这里路由一样是 .as_view()



 - 请求获取数据方式改变
    from rest_framework.views import APIView

 - 返回响应改变
    from rest_framework.response import Response



class BookListAPIView(APIView):

    def get(self,request):
        #获取 query 参数方式改变, 然而实际上他就是改了一个名字...
        #django -> request.GET
        query_params = request.query_params
        # return JsonResponse({'code':0,errmsg:"ok"})
        return Response(可直接返回 JSON 与 列表数据)

    def post(self,request):
        #获取 query/body 方法改变, 这里比较明显, drf 框架直接 request.data 即可
        # django -> request.POST/request.body.encode()
        data = request.data
        # return JsonResponse({'code':0,errmsg:"ok"})
        return Response(可直接返回 JSON 与 列表数据)


问题 1:
 - Response 浏览器请求返回 HTML 页面
     - 1.REST framework 提供了一个响应类 Response，
         - 使用该类构造响应对象时，响应的具体数据内容会被转换（ render渲染 ）
         - 符合前端需求的类型。
     - 2.REST framework 提供了 Renderer 渲染器，
         - 用来根据请求头中的 Accept（接收数据类型声明）来自动转换响应数据到对应格式。
         - 如果前端请求中未进行 Accept 声明，则会采用默认方式处理响应数据，
         - 我们可以通过配置来修改默认响应格式。
     - 3.所以这里的原因在于浏览器的请求头 Accept 为 text/html
 - 解决方案:
     - settings 文件中写入
        REST_FRAMEWORK = {
            'DEFAULT_RENDERER_CLASSES': (  # 默认响应渲染类
                'rest_framework.renderers.JSONRenderer',  # json渲染器
                'rest_framework.renderers.BrowsableAPIRenderer',  # 浏览API渲染器
            )
        }     

注意事项2:
     - REST framework 提供了 Parser 解析器，
         - 在接收到请求后会自动根据 Content-Type 指明的请求数据类型（如 JSON、表单 等）
         - 将请求数据进行 parse 解析，解析为类字典对象保存到 Request 对象中。
     - Request 对象的数据是自动根据 前端发送数据的格式() 进行解析之后的结果。
     - 无论前端发送的哪种格式的数据，我们都可以以统一的方式读取数据。
     - request.data / request.query_params
     - 第一个是将 django 的 post 接受参数方式简化
     - 第二个是将语义修正, 更加标准


-------------------------------------------------------------- GenericAPIView + Mixin 使用

 - 继承自 APIview，增加了对于列表视图和详情视图可能用到的通用支持方法。
     - 通常使用时，可搭配一个或多个Mixin扩展类。
 - 使用 GenericAPIView 类一般需要实现 queryset 属性或者重写 get_queryset 方法

 - Minin 为列表视图扩展类，提供list(request, *args, **kwargs) 方法快速实现列表视图，返回200状态码。
     - 该Mixin的list方法会对数据进行过滤和分页。


from rest_framework.generics import GenericAPIView

 - GenericAPIView 使用方式:
     class Test2(GenericAPIView):
        #查询结果集设置
        queryset = BookInfo.objects.all()
        #序列化器设置
        serializer_class = BookInfoModelSerializer
        def get(self, request):
            #获取查询结果集, 底层核心实际是 books = self.queryset
            books = self.get_queryset()
            #将查询结果集进行序列化, 底层核心实际还是 BookInfoSerializer(data=book, many=True)
            serializer = self.get_serializer(books, many=True)

        def post(self, request):
            data = request.data
            serializer = self.get_serializer(data=data)
            serializer.is_vaild()
            serializer.save()

 - GenericAPIView + Mixin 使用方式:
     class Test2(ListModelMixin,CreateModelMixin,GenericAPIView):
        #查询结果集设置
        queryset = BookInfo.objects.all()
        #序列化器设置
        serializer_class = BookInfoModelSerializer
        def get(self, request):
            #详情请看源码, 这里已经帮助我们将那三步骤全写了
            return self.list(request)

        def post(self, request):
            # 详情请看源码, 这里全写了...
            return self.create(request)

-------------------------------------------------------------- 几个可用子类视图

 - 1.这里的使用可能会困难, 想使用只能去阅读一下源码
#增加数据时使用
 - CreateAPIView
     from rest_framework.generics import CreateAPIView
     提供 post 方法
 
     继承自： GenericAPIView、CreateModelMixin
 
     class CreateAPIView(mixins.CreateModelMixin,
                        GenericAPIView):
        """
        Concrete view for creating a model instance.
        """
        def post(self, request, *args, **kwargs):
            return self.create(request, *args, **kwargs)
#查询所有时使用
 - ListAPIView
     from rest_framework.generics import ListAPIView
     提供 get 方法
     
     继承自：GenericAPIView、ListModelMixin
     
     class ListAPIView(mixins.ListModelMixin,
                      GenericAPIView):
        """
        Concrete view for listing a queryset.
        """
        def get(self, request, *args, **kwargs):
            return self.list(request, *args, **kwargs)
#查询指定时使用
 - RetireveAPIView
     from rest_framework.generics import RetrieveAPIView
     提供 get 方法
     
     继承自: GenericAPIView、RetrieveModelMixin
#删除指定时使用
 - DestoryAPIView
     from rest_framework.generics import DestroyAPIView
     提供 delete 方法
     
     继承自：GenericAPIView、DestoryModelMixin
#更新时使用
 - UpdateAPIView
     from rest_framework.generics import UpdateAPIView
     提供 put 和 patch 方法
     
     继承自：GenericAPIView、UpdateModelMixin
#指定更新时使用
 - RetrieveUpdateAPIView
     from rest_framework.generics import RetrieveUpdateAPIView
     提供 get、put、patch方法
     
     继承自： GenericAPIView、RetrieveModelMixin、UpdateModelMixin
#指定更新删除时使用
 - RetrieveUpdateDestoryAPIView
     from rest_framework.generics import RetrieveUpdateDestroyAPIView
     提供 get、put、patch、delete方法
     
     继承自：GenericAPIView、RetrieveModelMixin、UpdateModelMixin、DestoryModelMixin

-------------------------------------------------------------- GenericAPIView + Mixin 进一步学习

 - 这里就是关于分页的, 或者说是查询准确的数据

 - GenericAPIView
     class Text4(GenericAPIView):
        # 查询结果集设置( 这里是惰性, 要准确数据可以 filter, 实际上底层就是这么干的 )
        queryset = BookInfo.objects.all()
        # 序列化器设置
        serializer_class = BookInfoModelSerializer
        # 设置关键字 URL Query 参数名字
        lookup_field = 'id'

        def get(self, request, pk):
            #详情看源码, 这里就是获取 query 然后 filter 操作
            book = self.get_object()
            serializer = self.get_serializer(isinstance=book)
            return Response(serializer.data)

        def put(self, request, pk):
            pass

        def delete(self, request, pk):
            pass

-------------------------------------------------------------- 视图集 ViewSet

 - 一个ViewSet类只是一种基于类的View，它不提供任何方法处理程序（如get()orpost()），
     - 而是提供诸如list()和create()之类的操作。
 - 使用ViewSet类比使用View类有两个主要优点。
     - 重复的逻辑可以合并成一个类。例如我们只需要指定queryset一次，它将用于多个视图。
     - 通过使用路由器，我们不再需要处理自己的URL配置

 - 一个ViewSet类只是一种基于类的 View ，继承自 APIView ，
     - 作用也与 APIView 基本类似，提供了身份认证、权限校验、流量管理等。

 - 在 ViewSet 中，它不提供任何方法处理程序，需要我们自己重写该类并明确实现 action 方法。

 - 对于单个模型的 增删改查 放到一起去

from rest_framework.viewsets import ViewSet

class BookViewSet(ViewSet):
    #查询所有
    def list(self, request):
        pass
    #创建
    def create(self, request):
        pass
    #查询指定
    def retrieve(self, request, pk=None):
        pass
    #更新
    def update(self, request, pk=None):
        pass
    #更新指定
    def partial_update(self, request, pk=None):
        pass
    #删除
    def destroy(self, request, pk=None):
        pass


 - 一个ViewSet类同时提供以下可用属性

     - basename - 用于创建的URL名称的基础。
     - action   - 当前动作的名称（例如list，create）。
     - detail   - 布尔值，指示当前操作是否为列表或详细视图配置。
     - suffix   - 视图类型的显示后缀 - 镜像detail属性。

 - 视图集路由定义方式
     path('bookviewset/',views.BookViewSet({'get':'list'})),
     path('bookviewset/<pk>/',views.BookViewSet({'get':'retrieve'})),

-------------------------------------------------------------- 视图集 GenericViewSet (这里被略过了)

 - 继承自 GenericAPIView ，作用也与 GenericAPIVIew 类似 ，
     - 提供了 get_object 、 get_queryset 等方法便于列表视图与详情信息视图的开发。
     - 在 GenericAPIView 中，没有提供任何动作 action 方法，
     - 需要我们自己覆盖该类并混合所需的混合类，或者明确定义操作实现 action 方法

-------------------------------------------------------------- 视图集 ModelViewSet

 - ModelViewSet 类所继承 GenericAPIView，包括用于各种动作实现方式中，
     - 同时包括了 
     ListModelMixin、
     RetrieveModelMixin、
     CreateModelMixin、
     UpdateModelMixin、
     DestoryModelMixin。

 - 由提供的动作 ModelViewSet 类是
     .list()，
     .retrieve()，
     .create()，
     .update()，
     .partial_update()，
     .destroy()

 - 使用：
     - 因为 ModelViewSet 扩展 GenericAPIView，
     - 我们通常需要提供至少 queryset 和 serializer_class 属性

from rest_framework.viewsets import ModelViewSet
from book.serializers import BookInfoModelSerializer
from book.models import BookInfo

class BookModelViewSet(ModelViewSet):

    queryset = BookInfo.objects.all()
    serializer_class = BookInfoModelSerializer

 - 视图集的路由比较特殊

     from book import views
     urlpatterns = [
     ]
 
     from rest_framework.routers import DefaultRouter
     # 可以处理视图的路由器, 创建 router 实例
     router = DefaultRouter()
     # 注册视图集 1.列表视图与详情视图的公共部分 2.视图集 3.给列表视图或详情视图起一个别名
     # books/           公共为 books
     # books/<pk>/
     router.register('books', views.BookModelViewSet,basename='')
     #追加路由
     urlpatterns += router.urls

-------------------------------------------------------------- 视图集 ReadOnlyModelViewSet

 - 继承自GenericAPIVIew，同时包括了ListModelMixin、RetrieveModelMixin。
 - 与ModelViewSet它一样，它还包括各种操作的实现，
     - 但不同于ModelViewSet只提供“只读”操作，list()而且retrieve()

 - 各有各的好, 就看具体业务在哪, 比如说只用读的就用这个

-------------------------------------------------------------- 视图集路由生成

 - 下面两种方式的共同点
     - 都可以自动生成路由
 - 不同点
     - 只有 DefaultRouter 可以访问跟路由, 也就是不用加路径

 - 使用方式

 - 导入
     - from rest_framework.routers import DefaultRouter / SimpleRouter

 - 可以处理视图的路由器, 创建 router 实例
     router = DefaultRouter()

 - 使用 router 对象，并注册视图集, 注册语法为,( 这里会生成两个路由 prefix 与 prefix/pk/ )
     register(prefix, viewset, basename)
         - prefix    列表视图与详情视图的公共部分 ( 不用加/ )
         - viewset   视图集
         - basename  路由名称的前缀
             - 列表视图起名规则 basename-list
             - 详情试图        basename-detail
             - 一般路由名与别名一致即可, 原因是要求不要重复

 - 1.第一种方式 ( DefaultRouter )
     from book import views
     urlpatterns = []
     
     from rest_framework.routers import DefaultRouter
     # 可以处理视图的路由器, 创建 router 实例
     router = DefaultRouter()
     # 注册视图集 1.列表视图与详情视图的公共部分 2.视图集 3.给列表视图或详情视图起一个别名
     # books/           公共为 books
     # books/<pk>/
     router.register('books', views.BookModelViewSet,basename='')
     #追加路由
     urlpatterns += router.urls

 - 2.第二种方式 ( SimpleRouter )
     from book import views
     urlpatterns = []
     
     from rest_framework.routers import SimpleRouter
     # 可以处理视图的路由器, 创建 router 实例
     router = SimpleRouter()
     # 注册视图集 1.列表视图与详情视图的公共部分 2.视图集 3.给列表视图或详情视图起一个别名
     # books/           公共为 books
     # books/<pk>/
     router.register('books', views.BookModelViewSet,basename='')
     #追加路由
     urlpatterns += router.urls

 - 添加路由另一种写法
     urlpatterns = [
         ...
         path('', include(router.urls))
     ]


-------------------------------------------------------------- DRF 框架 - 权限

 - 权限控制可以限制用户对于视图的访问和对于具体数据对象的访问。
 - 在执行视图的 dispatch() 方法前，会先进行视图访问权限的判断
 - 在通过 get_object() 获取具体对象时，会进行对象访问权限的判断

 - 1.提供的权限
     - AllowAny 允许所有用户
     - IsAuthenticated 仅通过认证(也就是登陆) 的用户
     - IsAdminUser 仅管理员用户
     - IsAuthenticatedOrReadOnly 认证的用户可以完全操作，否则只能get读取


 - 可以在配置文件中设置默认的权限管理类，如

     REST_FRAMEWORK = {
         'DEFAULT_PERMISSION_CLASSES': (
             'rest_framework.permissions.IsAuthenticated',
         )
     }

 - 如果未指明，则采用如下默认配置, ( 默认 )

     'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.AllowAny',
     )


 - 2.对指定视图设置权限

     from rest_framework.permissions import AllowAny
     - 类里面写入 
         - permission_classes = [AllowAny]


-------------------------------------------------------------- DRF 框架 - 认证

 - 身份验证本身不会允许或不允许传入的请求，它只会标识发出请求的凭据。
 - 认证管理一般和权限管理配合使用。

 - 只有认证验证没权限验证将没有任何效果()
# from rest_framework.authentication import TokenAuthentication
 - 在 settings 文件中写入即可开启验证
     - 验证可以是多个, Session 没有就验证 Token

     REST_FRAMEWORK = {
         # 默认的认证列表： session
         'DEFAULT_AUTHENTICATION_CLASSES': [
             'rest_framework.authentication.SessionAuthentication',  # session认证
             'rest_framework.authentication.TokenAuthentication',  # session认证
         ]
     }

-------------------------------------------------------------- DRF 框架 - 分页

 - 系统为我们提供了两个分页类

 - 只有 GenericAPIVIew 及其子类才能使用分页
     - APIView ViewSet 无法使用系统的分页


 - 我们可以在配置文件中设置全局的分页方式，如：
     REST_FRAMEWORK = {
         'DEFAULT_PAGINATION_CLASS':  'rest_framework.pagination.PageNumberPagination',
         'PAGE_SIZE': 100  # 每页数目,这里可以不写, 直接 ?limit=100 即可
     }

 - 单独视图设置分页器
     from rest_framework.pagination import LimitOffsetPagination, PageNumberPagination
     - 这里点进去就可以看教程
     - 类里面写入
         - pagination_class = LimitOffsetPagination / PageNumberPagination / PageNum
             - 注意 PageNumberPagination 不设置 page_size 会自动关闭
                 - 1. 在配置文件中设置 page_size
                 - 2. 区别在于这里的返回页数是这边定的
                 - 3. 去继承 / 重写
                     class PageNum(PageNumberPagination):
                        page_size = 5                       #开启分页的开关
                        page_size_query_param = 'page_size' #Url 中 query 参数的名词
                        max_page_size = 20                  #最大多少条数据





























