Django 框架
-------------------------------------------------------------- Start

 - 1.创建虚拟环境
python -m venv 项目名称

 - 2.开启虚拟
Script/activate.bat
powershell 命令行，脚本换成 Activate.ps1

 - 3.关闭虚拟
Script/deactivate.bat

 - 4.下载 Django 库 ( 跳到目录之内下载 )
pip install django

 - 5.创建 Django 项目
django-admin startproject 项目名字

 - 6.创建子应用(可选)
python manage.py startapp name

-------------------------------------------------------------- Django 文件刨析

settings.py - 项目的整体设置

urls.py 	- 进行路由匹配

wsgi.py 	- 项目与 WSGI 兼容的 Web 服务器入口

manage.py 	- 项目管理文件

-------------------------------------------------------------- Django 运行

 - 只能运行 manage.py 文件(需要在虚拟环境中)( 默认 127.0.0.1 )
 	 - python manage.py runserver

-------------------------------------------------------------- Django 创建子应用

 - 需要在 manage.py 目录下执行命令
python manage.py startapp name

-------------------------------------------------------------- Django 子文件刨析

 - admin.py 		文件跟网站的后台管理配置相关

 - apps.py 			文件用于配置当前子应用的相关信息

 - migrations 		目录用于存放数据库迁移历史文件

 - models.py 		文件用户保存数据库模型类

 - tests.py 		文件用于开发测试用例, 编写单元测试

 - views.py 		文件用于编写 Web 应用视图

-------------------------------------------------------------- Django 注意实现

 - 可以选择将指针放到准确目录上, 将python 解释器路径从新设置
 	 - 至 Script 目录下
 	 - 执行 Activate.ps1/activate.bat 直到命令行前面出现 绿色(文件夹名称) 标识
 	 	 - 即为成功进入虚拟环境

-------------------------------------------------------------- 主文件注册子目录

 - 主settings文件
 	 - 创建 子应用 而不注册会出错

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'MonikaAPP'
]

-------------------------------------------------------------- ORM 是什么

 - 一套面向对象的语法格式
 - Django 以使用
 - 调用方法即可使用不同的数据库, 一套语法解决多个数据库语言不同步问题

		ORM								DB
		 类 				<->			  数据表
		对象 			<->			  数据行
		属性				<->			   字段

-------------------------------------------------------------- ORM 使用

 - 已忽略文件的自动导入代码
 - 转到 子app 中的 models.py 文件中写入类
1.我们的模型类需要继承自 models.Model
2.系统会自动为我们添加一个逐渐 - id
3.字段
	- 字段名=model.类型(选项)
		 - 字段名实则就是数据表的字段名
		 - 字段名不要使用 Mysql Python 等关键字
4.关于本章可以参考 Mysql 笔记

class Book(models.Model):
	# 系统会自动为我们添加一个逐渐 - id
	name = models.CharField( Max_length=10 )		===      			varchar(10)

class Person(models.Model):
	# 系统会自动为我们添加一个逐渐 - id
	name = models.CharField( Max_length=10 )		===      			varchar(10)
	gender = models.BooleanField()					=== 				布尔值	
	book = models.ForeignKey(BookInfo,on_delete = model.CASCADE) === 	外键

-------------------------------------------------------------- ORM 模型迁移

1.根据你所写入的内容形成对应的 SQL 语句
 - 生成对应的迁移文件
 	- python manage.py makemigrations
 - 执行迁移 (执行文件)
	- python manage.py migrate

2.检测不到变化请移步至子文件导入

3.执行文件成功后表在哪?
 - 移步至 setting.py 文件
 
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

-------------------------------------------------------------- 站点管理

 - 界面本地化
 - 创建管理员
 - 注册模型类
 - 发布内容到数据库
     - 打开网站后,网址加入 /admin
     - 创建超级用户管理员
     - python manage.py createsuperuser
         - 注意密码不显示

-------------------------------------------------------------- Settings 选项

# 语言
LANGUAGE_CODE = 'zh-Hans'
# 时区
TIME_ZONE = 'Asia/Shanghai'

USE_I18N = True

USE_TZ = True

-------------------------------------------------------------- views 视图

 - 打开 views 文件
 - 所谓的视图实际就是 Python 函数
 - 视图函数有两个要求
     - 视图函数第一个参数是接受请求
     - 必须返回一个响应
# requests 参数实则就是下面的
# from django.http import HttpRequest
HttpResponse('响应体', content_type='image/jpeg' <- 响应格式)
from django.http import HttpResponse
def index(requests):

    return HttpResponse("ok")

-------------------------------------------------------------- 路由匹配

 - 打开 urls.py 
from django.contrib import admin
from django.urls import path
from MonikaAPP.views import index
urlpatterns = [
    path('admin/', admin.site.urls),
    path("index/", index)
]

-------------------------------------------------------------- 路由匹配2

 - 子应用创建 urls 的方式
 - 右键新建 urls.py 文件

from django.urls import path
from 文件名.views import 函数名
urlpatterns = [
    # path(路由,路由函数名)  
    path("index/",函数名)
]


 - 总路由文件
from django.contrib import admin
from django.urls import path
from django.urls import include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('访问子应用路径', include('文件名.urls'))
]

-------------------------------------------------------------- 模板

 - 创建文件夹 templantes
 - 创建文件名对应目录 例: Monika
     - 存放 html,css,js 文件
 - 打开 Settings文件
 - 找到 TEMPLATES["DIRS"] 位置
     - 参照下面路径配置方式
     - ['DIRS': [BASE_DIR / 'templantes'],]
 - 返回需要输出模板文件的地方
 - 打开 views 文件

def index(requests):
    print(requests)
    return render(requests,'Monika/index.html')

-------------------------------------------------------------- 模板渲染数据(了解)

def index(requests):
    object = {
        name:"monika"
    }
    return render(requests,'Monika/index.html',context=object)

<div>{{name}}</div>

-------------------------------------------------------------- setting部分内容讲解

BASE_DIR = 内部文件的最近外层文件
# C:\Users\Lenovo\Desktop\Django学习\学习  ,   MonikaAPP/学习

DEBUG = True
# 开启调试模式
# 项目部署时请关闭

ALLOWED_HOSTS = ['*',"127.0.0.1"]
# 允许以什么样的形式访问我们的项目
# 默认 127.0.0.1
# * 表示可以使用 IP, 也可以使用 127.0.0.1

-------------------------------------------------------------- 静态文件

 - 在跟文件底下创建 static 文件, 可以将静态文件(js/css/html/img) 文件放入

 - settings 文件加入配置, 告知文件路径( DEBUG 需要为 TRUE )
    STATICFILES_DIRS = [ BASE_DIR / 'static' ]
    # http://127.0.0.1:8000/static/001.jpg 当时访问路径

-------------------------------------------------------------- apps 了解

 - 和子应用配置相关的

-------------------------------------------------------------- 数据库修改为 MySQL

 - 开启虚拟环境
 - pip install mysqlclient
 - 接下来开启 MySQL 并且创建一个库
create database 名字

到 settings 中的 DATABASES 进行配置

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',   使用什么命令
        "HOST":"127.0.0.1",                     主机地址
        "PORT":3306,                            端口号
        "USER":"root",                          权力
        "PASSWORD":"sxhmzz840845135",           密码
        'NAME': "django学习",                   数据库名
    }
}

-------------------------------------------------------------- 关于选项

 - unique = true                        不许重复,默认值是False
 - default = 1                          默认值
 - null = False                         非空
 - Max_length = 20                      最大 20 字符, 仅可用在 CharField 上
 - choices = 有序元组变量名              只能在这里面选择(约束数据),填写 1 / 2
     - 有序元组变量名 = ( (1,'male'),(2,"female") )
 - blank                                如果为True，则该字段允许为空白，默认值是False
 - db_column                            字段的名称，如果未指定，则使用属性的名称
 - db_index                             若值为True, 则在表中会为此字段创建索引，默认值是False

 - primary_key                          若为True，则该字段会成为模型的主键字段，
                                             - 默认值是False，一般作为AutoField的选项使用

-------------------------------------------------------------- 关于 models.

models.CharField()                                                  varchar()
models.SmallIntegerField(choices= ,default= )                       内容约束
models.BooleanField()                                               True/False
models.DateField()                                                  日期
models.ForeignKey(另一个类,on_delete=models.CASCADE)                 外键约束
     - CASCADE          主表没了, 子表一并删除
     - PROTECT          子表还在则无法删除主表, 抛出异常( ProtectedError )
     - SET_NULL         主表没了, 无关紧要, 子表继续执行
     - SET_DEFFAULT     候选人
     - SET              选举候选人(设置特定值或调用特定方法)
     - DO_NOTHING       关我屁事

 - 补充:

     - models.AutoField()   
         - 自动增长的IntegerField，通常不用指定，
         - 不指定时Django会自动创建属性名为id的自动增长属性

     - models.BooleanField()    
         - 布尔字段，值为True或False

     - models.NullBooleanField()    
         - 支持Null、True、False三种值

     - models.CharField()   
         - 字符串，参数max_length表示最大字符个数

     - models.TextField()   
         - 大文本字段，一般超过4000个字符时使用

     - models.IntegerField()    
         - 整数

     - models.DecimalField()    
         - 十进制浮点数， 参数max_digits表示总位数， 参数decimal_places表示小数位数

     - models.FloatField()  
         - 浮点数

     - models.DateField()   
         - 日期， 参数auto_now表示每次保存对象时，自动设置该字段为当前时间，
         - 用于"最后一次修改"的时间戳，它总是使用当前日期，默认为False； 
         - 参数auto_now_add表示当对象第一次被创建时自动设置当前时间，用于创建的时间戳，
         - 它总是使用当前日期，默认为False; 
         - 参数auto_now_add和auto_now是相互排斥的，组合将会发生错误

     - models.TimeField()   
         - 时间，参数同DateField

     - models.DateTimeField()   
         - 日期时间，参数同DateField

     - models.FileField()   
         - 上传文件字段

     - models.ImageField()  
         - 继承于FileField，对上传的内容进行校验，确保是有效的图片

-------------------------------------------------------------- 模型类的基本定义(外键)

 - 模型类 需要继承自 models.Model
    - id 默认生成
    - 一个表就是一个类
    - 字段就是属性
        - 属性名 = models.类型( 选项 )
        - 属性名就是字段名 
        - 不要使用连续的下划线 __
 - 选项 (是否唯一, 默认值, CharField 必须有 Max_length)
 - 默认表的名称时 子应用名 + 类名
     - 修改表的名字


例子:
class BookInfo(models.Model):
    name = models.CharField(max_length=10,unique=true)
    pub_date = models.DateField(null=True)
    readcount = models.IntegerField(default=0)
    commentcount = models.IntegerField(default=0)
    isdelete = models.BooleanField(default=False)

    # 改变表名
    class Meta:
        db_table = 'bookinfo' 

class PepoleInfo(models.Model):

    gender_choice = (
        (1,'male'),
        (2,"female")
    )

    name=models.CharField(max_length=10,unique=True)
    gender = models.SmallIntegerField(choices=gender_choice,default=1)
    description = models.CharField(max_length=100,null=True)
    is_delete = models.BooleanField(default=False)

    #外键 - 系统会自动为外键添加 _id
    book=models.ForeignKey(BookInfo)
    #这里确实进行了关联, book_id 与 BookInfo 的 ID 进行了关联

-------------------------------------------------------------- 业务流程中实现增删改查的地方

 - 在 views.py 文件中
from django.shortcuts import render
from django.http import HttpResponse
from book.models import BookInfo
def index(requests):
    #实现 增删改查 的地方
    books = BookInfo.objects.all()
    print(books)
    return HttpResponse("ok")

-------------------------------------------------------------- Shell 工具

 - Django 的 manage 工具提供了 shell 命令,帮助我们配置好当前工程的运行环境
     - 可以在终端中直接执行 Python 指令
     - 注意让终端同样进入虚拟环境

 - python manage.py shell
      - 文件内容更改需要重新执行

from 文件.models import 类名
>>> 类名.objects.all()                            #打印类内容
# - 类似与 select * form ...
# 这里会打印类, 如果没有重写 类 的 __str__ 方法, 就会打印 class 之类的
# 需要重写 __str__ 方法
# def __str__(self):
#    return self.name
# <QuerySet [<BookInfo: 射雕英雄传>, <BookInfo: 天龙八部>, <BookInfo: 笑傲江湖>, <BookInfo: 雪山飞狐>]>

-------------------------------------------------------------- MySQL 数据的增删改查

                                             - 增加数据(views.py)
from book.models import BookInfo
# (方式一)
book = BookInfo(
    name = "生命的备件",
    pub_date = "2016-8-26",
    readcount = 10
)
#上方只是将需要的数据写入了内存, 需要执行下面的命令
book.save()

# (方式二)
# - objects 相当于一个代理, 帮助我们实现增删改查
BookInfo.objects.create(
    name = "Clannad",
    pub_date = "2016-8-26",
    readcount = 10
)

                                             - 修改数据(views.py)
# (方式一)
# select * from BookInfo where id=6
book = BookInfo.objects.get(id=6)
book.name = "紫罗兰的永恒花园"
#上方只是将需要的数据写入了内存, 需要执行下面的命令
book.save()

# (方式二)
BookInfo.objects.filter(id=6).update(name="未来日记",commentcount=666)

                                             - 删除数据(views.py)
# (方式一)
book = BookInfo.objects.get(id=1)
book = BookInfo.objects.filter(id=5)
# 物理删除 / 逻辑删除( is_delete = False )
book.delete()
                                             - 查询数据(views.py)

get - 查询单一结果, 如果不存在抛出 DoesNotExist 异常
all - 查询多个结果
count - 查询结果数量

# 查询单一结果
try:
    book = BookInfo.objects.get(id=1)
except BookInfo.DoesNotExist:
    print("查询结果不存在")

# 查询多个结果
book = BookInfo.objects.all()

# 查询结果数量
book = BookInfo.objects.all().count()
book = BookInfo.objects.count()

二. 过滤查询()

filter  过滤出多个结果
exclude 排除掉符合条件剩下的结果
get     过滤单一结果

BookInfo.objects.filter(属性名__运算符=值)     获取 N 个结果
BookInfo.objects.exclude(属性名__运算符=值)    获取 N 个结果
BookInfo.objects.get(属性名__运算符=值)        获取 1 个结果 或者 开摆

#查询编号为一的图书
BookInfo.objects.get(id=1)              #简写形式
BookInfo.objects.get(id__exact = 1)     #完整形式
BookInfo.objects.get(pk=1)              #另类方式

#查询书名中包含'湖'的图书
BookInfo.objects.filter(name__contains='湖')

#查询书名中'部'结尾的图书
BookInfo.objects.filter(name__endswith='部')

#查询书名为空的图书
BookInfo.objects.filter(name__isnull=True)

#查询编号为 1, 3, 5 的图书
# select * from peopleinfo where id in (1,3,5,7,9);
BookInfo.objects.filter(id__in=[1,3,5])

#查询编号大于3图书
# 大于 gt 大于等于 gte
# 小于 lt 小于等于 lte
# 不等于 BookInfo.objects.exclude()
BookInfo.objects.filter(id__gt=3)

#查询1980年发布的图书
BookInfo.objects.filter(pub_date__year=1980)

#查询 1980 1月1日 之后年发布的图书
BookInfo.objects.filter(pub_date__gt=1980-1-1)

-------------------------------------------------------------- F 对象( 两个属性之间进行比较 )

 - 进行两个属性的比较, F 对象
     - 注意大写 F
from django.db.models import F
模型类名.objects.filter(属性名__运算符=F('第二个属性名'))
BookInfo.objects.filter(readcount__gt=F('commentcount'))

#查询阅读量大于两倍评论量的图书
BookInfo.objects.filter(readcount__gt=F('commentcount')*2)

-------------------------------------------------------------- Q 对象( 两个属性之间进行比较 )

 - 多个过滤器逐个调用表示逻辑与关系, 同 SQL 语句中的 Where 与 and 关键字

#阅读量大于 20 且标号小于 3 的图书
BookInfo.objects.filter(readcount__gt=20,id__lt=3)                     #并且
BookInfo.objects.filter(readcount__gt=20).filter(id__lt=3)             #并且
BookInfo.objects.filter(Q(readcount__gt=20)&Q(id__lt=3))               #并且

from django.db.models import Q
模型类名.objects.filter(Q(属性名__运算符=值)|Q(属性名__运算符=值))        #或者
模型类名.objects.filter(Q(属性名__运算符=值)&Q(属性名__运算符=值))        #并且
模型类名.objects.filter(~Q(属性名__运算符=值)&~Q(属性名__运算符=值))      #除了 not/~Q

-------------------------------------------------------------- 聚合函数和排序函数

 - 聚合函数()
使用 aggregate() 过滤器调用聚合函数, 聚合函数包括 [Avg平均, Count数量, Max最大, Min最小, Sum求和]
     被定义在 django.db.models 中

#查询图书的总阅读量
from django.db.models import Sum
BookInfo.objects.aggregate(Sum('readcount'))
返回 {'readcount': 126}

 - 排序函数()
# select * from peopleinfo order by id [desc]

BookInfo.objects.all().order_by('readcount')    从小到大
BookInfo.objects.all().order_by('-readcount')   从大到小

-------------------------------------------------------------- 级联排序 ( 关联查询 )

 - 关联查询()          
由一到多的访问模型中, 系统会为我们自动添加一个 关系模型类名小写_set 字段
与当前有关联的内容

 # 查询书籍为 1 的所有人物信息 
book = BookInfo.objects.get(id=1)
book.peopleinfo_set.all()

 # 查询人物为 1 的书籍信息
person = peopleinfo.objects.get(id=1)
person.book
person.book.name

-------------------------------------------------------------- 关联查询和管理过滤查询

#语法形式
# 查询为 1 的数据,条件为 N
# 模型类名.objects.(关联模型类名小写__字段名__运算符=值)

#查询图书,要求图书人物为 '郭庆'
BookInfo.objects.filter(peopleinfo__name='郭靖')

#查询图书, 要求图书中人物包含 八
BookInfo.objects.filter(peopleinfo__description__contains='八')

#查询书名为天龙八部的所有人物
PeopleInfo.objects.filter(book__name="天龙八部")

#查询图书阅读量大于 30 的所有人物
PeopleInfo.objects.filter(book__readcount__gt=30)

-------------------------------------------------------------- 一切的运算符

__exact = <str>             =                   可以省略    
__contains = <str>          包含           
__endswith = <str>          包含且结尾为     
__isnull = <boolean>        是否为空
__in = <list>               包含在列表
__gt = <number>             大于
__lt = <number>             小于
__gte = <number>            大于等于
__lte = <number>            小于等于
__year = <number>           需要四位数

-------------------------------------------------------------- 查询集 QuerySet

                                                                1.惰性执行()
创建查询集不会访问数据库，直到调用数据时，才会访问数据库，
    - 调用数据的情况包括迭代、序列化、与if合用
例如，当执行如下语句时，并未进行数据库查询，只是创建了一个查询集books

books = BookInfo.objects.all()

继续执行遍历迭代操作后，才真正的进行了数据库的查询

for book in books:
    print(book.name)



                                                                2.缓存执行()
经过存储后，可以重用查询集
    - 第二次使用缓存中的数据。

books=BookInfo.objects.all()
[book.id for book in books]



                                                                3.限制查询集()
 - 不支持负数
books = BookInfo.objects.all()[0:2]
<QuerySet [<BookInfo: 射雕英雄传>, <BookInfo: 天龙八部>]>


                                                                4.分页()
books = BookInfo.objects.all()
from django.core.paginator import Paginator
paginator=Paginator(books,2)
page_books = paginator.page(1)
total_page=paginator.num_pages

-------------------------------------------------------------- HttpRequest 对象(传参)

 - 提取URL的特定部分，如/weather/beijing/2018，可以在服务器端的路由中用正则表达式截取；
 - 查询字符串（ query string )，形如 key1=value1&key2=value2；
 - 请求体（ body ）中发送的数据，比如表单数据、json、xml；
 - 在http报文的头（ header ）中。

from django.urls import path
from book.views import shop
urlpatterns=[
    path('<city_id>/<shop_id>/',shop)
]

def shop(request, city_id, shop_id):
    pass

-------------------------------------------------------------- 查询字符串( Query String )

 - query 参数
 - 请求路径?查询字符串
 - QueryDict 区别于普通字典的为
     - 字典的特性
     - 一键多值,需要用  query_params.getlist("键名")  来获取值

def shop(request):
    query_params = request.GET
    print(query_params.get("键名"))

-------------------------------------------------------------- 传递 From 表单数据

 - Django 默认不允许我们发送 Post 请求
 - 想要发送 Post 请求需要在 setting文件 中
     - 将 MIDDLEWARE 对象的
     - 'django.middleware.csrf.CsrfViewMiddleware', 
     注释掉就行了

-------------------------------------------------------------- JSON 数据请求与发送

 - JSON 数据无法通过 requests.POST 获取
 - requests.body 获取会得到 二进制数据, 需要 decode() 解码, 解码之后会成为字符串
     - JSON 形式的字符串可以转换为 python 的字典
     - 需要导入 import json
     - json.loads(body)

 - 表单数据 requests.POST
 - JSON 数据 requests.body

-------------------------------------------------------------- 请求头

 - 可以通过 requests.META 属性获取请求头中的 headers 中的数据
     - requests.META 为字典类型

-------------------------------------------------------------- 转化器的使用( 在路径时就进行验证 )

 - 系统为我们提供了一些路由转换器位置在django.urls.converters.py

from django.urls import path
from book.views import shop
from django.urls import converters      #在路径时就进行验证

# <转换器名字:变量名>
# 转换器会对变量数据进行验证，正则的验证

urlpatterns=[
    path('<int:city_id>/<int:shop_id>/',shop)
]


DEFAULT_CONVERTERS = {
    'int': IntConverter(), # 匹配正整数，包含0
    'path': PathConverter(), # 匹配任何非空字符串，包含了路径分隔符
    'slug': SlugConverter(), # 匹配字母、数字以及横杠、下划线组成的字符串
    'str': StringConverter(), # 匹配除了路径分隔符（/）之外的非空字符串，这是默认的形式
    'uuid': UUIDConverter(), # 匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00
}

-------------------------------------------------------------- 自定义转化器的使用( 在路径时就进行验证 )

 - 比如：在工程根目录下，新建converters.py文件，用于自定义路由转换器
 - 转换器好像已经是 严格匹配了 无需再次 严格
class MobileConverter:
  """自定义路由转换器：匹配手机号"""
  # 匹配手机号码的正则
  regex = '1[3-9]\d{9}'

  def to_python(self, value):
      # 将匹配结果传递到视图内部时使用
      return int(value)

  def to_url(self, value):
      # 将匹配结果用于反向解析传值时使用
      return str(value)


from django.urls.converters import register_converter                  # 注册自定义路由转换器
# register_converter(自定义路由转换器, '别名')
register_converter(MobileConverter, 'mobile')

urlpatterns = []
# 使用自定义路由转换器

# 测试path()中自定义路由转换器提取路径参数：手机号 http://127.0.0.1:8000/18500001111/
# - 注意接受参数
path('<mobile:phone>/',register)

-------------------------------------------------------------- HttpResponse 对象

- 1. JsonResponse()
 - 将 Python 的 dist字典 转换成 JSON 格式

# 设置响应头Content-Type为application/json
from django.http import JsonResponse
info = {'name':'惠璃','age':"18"}
def response(request):
    return JsonResponse(data=info)

# 当数据为 列表包裹字典情况时
info = [
    {'name':'惠璃','age':'18'},
    {'name':'龙次','age':'18'}
]

def response(request):
    return JsonResponse( data=info, safe=False )

safe = 安全
safe = True  : 我们的数据为字典数据
safe = False : 我们的数据为非字典数据


-------------------------------------------------------------- 转化 JSON

import json as JSON 
from django.http import JsonResponse

 - 将 Python 的 dist字典 转换成 JSON 格式
     - return JsonResponse( data=info, safe=False )

 - JSON 形式的字符串可以转换为 python 的字典
     - JSON.loads()

 - 字典转化为字符串
     - json.dumps()

-------------------------------------------------------------- redirect 重定向

from django.shortcuts import redirect

def response(request):
    return redirect('/get_header')

-------------------------------------------------------------- Cookie饼干 && Session令牌 ( 状态保持 )


 - 1. 浏览器请求服务器是无状态的。
 - 2. 无状态：指一次用户请求时，
        - 浏览器、服务器无法知道之前这个用户做过什么，每次请求都是一次新的请求。
 - 3. 无状态原因：浏览器与服务器是使用 Socket 套接字进行通信的，
        - 服务器将请求结果返回给浏览器之后，
            - 会关闭当前的 Socket 连接，
            - 而且服务器也会在处理页面完毕之后销毁页面对象。
 - 4. 有时需要保持下来用户浏览的状态，比如用户是否登录过，浏览过哪些商品等
 - 5. 实现状态保持主要有两种方式：
        - 在客户端存储信息使用 Cookie
        - 在服务器端存储信息使用 Session

-------------------------------------------------------------- 饼干(Cookie)

 - 一些饼干... 一些饼干...
 - 追踪用户行为常用( html指纹技术? )
 - Cookie 是由服务器端生成
 - 下次请求服务器时会自动发送 Cookie( 浏览器开启 Cookie 情况下 )

                浏览器        第一次访问没有 Cookie 信息  ->    服务器
                浏览器        返回 Cookie                <-    服务器
                浏览器        请求携带 Cookie 信息        ->   服务器( 返回相关 Cookie 处理内容 )
                浏览器        请求携带 Cookie 信息        ->   服务器( 返回相关 Cookie 处理内容 )

 - Cookie = Key-Value 形式
 - Cookie 是基于域名安全的, 不同网站之间无法访问 Cookie

-------------------------------------------------------------- 设置饼干( 设置Cookie )

 - 设置 response 获取 requests      #生命周期
 - response.set_cookie(key, value, max_age = 秒)       #设置 Cookie (默认浏览器关闭时销毁)
 - requests.COOKIES.get('键名')                        #获取 
 - response.delete_cookie('键名')                      #删除 Cookie

def set_cookie(requests):
    query_Name = requests.GET.get("username")   
    response =  HttpResponse("set_Cookie")
    response.set_cookie('name',query_Name)
    print(requests.COOKIES['name'])
    return response

-------------------------------------------------------------- 设置Session

 - Django 默认启用 Session
    - 'django.contrib.sessions.middleware.SessionMiddleware' - setting 文件
 - 保存在 服务器 端
 - 直接就加密了
 - 需要依赖于 Cookie(曲奇饼干)

                浏览器        第一次访问没有 Cookie 信息  ->    服务器( 保存数据,生成 Cookie )
                浏览器        返回 Cookie[空],sessionID  <-    服务器( 返回携带 SessionID 的 Cookie 信息 )
                浏览器        请求携带 C包含S 信息        ->   服务器( Session 指向的数据内容 )
                浏览器        请求携带 C包含S 信息        ->   服务器( Session 指向的数据内容 )

requests.session['userID'] = user_id
requests.session['userName'] = userName
requests.session['message'] = "你好, 这是设置了 Session 的 message 内容"

 - 在数据库 Mysql 中 session_key 就是服务器将要发送给浏览器的 Session 凭证, 也就是每次
     - 浏览器访问服务器去携带 Cookie 的时候, 服务器解析 Cookie 中的 Session 凭证, 凭借 session_key 
     - 访问 session_data 中的加密数据, 并将加密数据解析到我们的读取 username = requests.session['user_name'] 中
     - 也就是所谓的数据存储在服务器中
 - 一个浏览器对应一个 SessionID 
 - 实现 Session 的时候, 系统会自动实现 Cookie

-------------------------------------------------------------- 状态保持

1. login()方法介绍
 - 状态保持：
 - 将通过认证的用户的唯一标识信息（比如：用户ID）写入到当前session会话中
    - login()方法：
 - Django用户认证系统提供了 login() 方法
 - 封装了写入session的操作，帮助我们快速实现状态保持
     - login()位置： django.contrib.auth.__init__.py文件中
 - login(request, user)

2. login()方法使用
# 保存注册数据
from django.contrib.auth import login
try:
    user = User.objects.create_user(username=username, password=password, mobile=mobile)
except DatabaseError:
    return http.JsonResponse({'code': 400, 'errmsg': '注册失败!'})

# 实现状态保持
login(request, user)

# 响应注册结果
return http.JsonResponse({'code': 0, 'errmsg': '注册成功!'})

-------------------------------------------------------------- 读取Session

 - user_id = requests.session.get('user_id')
 - username = requests.session.get('user_name')
 - 使用常规读取字典的方式可能会导致报错
    - .get()没有则 None, 不会报错

-------------------------------------------------------------- Session 存储位置更改       

 - 官网: https://django-redis-chs.readthedocs.io/zh_CN/latest/
 - MySQL 终是慢的, 源于硬盘, 那么更换数据库, 大抵 Redis 会更好
     - 正如我门前有两颗树, 一颗是 二叉树, 另一个也是 二叉树

 - 安装扩展 (虚拟) pip install django-redis

在settings.py文件中做如下设置
# Session 保存在 Redis 中
CACHES = {                  
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',         #让 Redis 实现我们的缓存
        'LOCATION': 'redis://127.0.0.1:6379/1',             #IP地址,1号库
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}
SESSION_ENGINE = 'django.contrib.sessions.backends.cache'
SESSION_CACHE_ALIAS = 'default'

-------------------------------------------------------------- Session 相关操作

1） 以键值对的格式写session。
     - request.session['键'] = 值

2）根据键读取值。
     - request.session.get('键',默认值)

3）清除所有 session ，在存储中删除值部分。
     - request.session.clear()

4）清除所有 session 数据，在存储中删除 session 的整条数据。
     - request.session.flush()

5）删除session中的指定键及值，在存储中只删除某个键及对应的值。
     - del request.session['键']

6）设置session的有效期
     - request.session.set_expiry(value)

如果value是一个整数，session将在value秒没有活动后过期。
如果value为0，那么用户session的Cookie将在用户的浏览器关闭时过期。
如果value为None，那么session有效期将采用系统默认值， 默认为两周，可以通过在settings.py中设置SESSION_COOKIE_AGE来设置全局默认值。

-------------------------------------------------------------- 类视图

 - 在Django中也可以使用类来定义一个视图，称为 类视图 
     - 使用类视图可以将视图对应的不同请求方式以类中的不同方法来区别定义

from django.views.generic import View

class RegisterView(View):
    """类视图：处理注册"""

    def get(self, request):
        """处理GET请求，返回注册页面"""
        return render(request, 'register.html')

    def post(self, request):
        """处理POST请求，实现注册逻辑"""
        return HttpResponse('这里实现注册逻辑')

 # - 配置路由时，使用类视图的as_view()方法来添加。

urlpatterns = [
    path('register/', views.RegisterView.as_view()),
]

-------------------------------------------------------------- 多继承和 MRO 排序

# 登陆用户访问, 未登录用户跳转登陆界面
# LoginRequiredMixin 
#    - 判断, 只有登陆用户才可以运行页面 admin 页面
#    - 失败会跳转到系统的 accounts/login 页面

from django.contrib.auth.mixins import LoginRequiredMixin

class login(LoginRequiredMixin, View)

 - MRO 排序
 
        object
           ^
           D   
      ->       <-
    B             C
        <- A ->

 - 实际调用顺序( 查找顺序 )
     - A -> B -> C -> D -> object

 - 所以也就是说 LoginRequiredMixin 与 View 顺序会对代码结果产生影响

-------------------------------------------------------------- 中间件

 - 创建新的文件 名字叫 middleware.py
 - from django.utils.deprecation import MiddlewareMixin
 - 请查询源码, __call__ 方法里面的 if 语句中

class TestMiddleWare(MiddlewareMixin):

    def process_request(self, request):                  # 每次请求之前都会调用执行
        pass

    def process_response(self, request, response):       # 每次响应之前都会调用执行
        ...
        return response

 - 注册中间件

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    # 'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'book.middleware.TestMiddleWare'
]

-------------------------------------------------------------- 中间件执行顺序

 - 在请求视图被处理前, 中间件由上至下执行的        请求

 - 在请求视图被处理后, 中间件由下至上执行的        响应

-------------------------------------------------------------- 常用工程目录结构

 - libs 存放第三方的库文件

 - utils 存放项目自己定义的公共函数或类等

 - apps 存放Django的应用

 - templates 模板文件存放文件夹

-------------------------------------------------------------- 配置 日志 文件 ( 线上排错 )

 - 收集线上的一些问题
 - 记录用户行为
 - 程序根目录准备 logs 文件夹
     - 增加 .gitkeep 文件
 - git 自动忽略 logs 文件

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,  # 是否禁用已经存在的日志器
    'formatters': {  # 日志信息显示的格式
        'verbose': {
            'format': '%(levelname)s %(asctime)s %(module)s %(lineno)d %(message)s'
        },
        'simple': {
            'format': '%(levelname)s %(module)s %(lineno)d %(message)s'
        },
    },
    'filters': {  # 对日志进行过滤
        'require_debug_true': {  # django在debug模式下才输出日志
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    'handlers': {  # 日志处理方法
        'console': {  # 向终端中输出日志
            'level': 'INFO',
            'filters': ['require_debug_true'],
            'class': 'logging.StreamHandler',
            'formatter': 'simple'
        },
        'file': {  # 向文件中输出日志
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': os.path.join(BASE_DIR, 'logs/meiduo.log'),  # 日志文件的位置
            'maxBytes': 300 * 1024 * 1024,
            'backupCount': 10,
            'formatter': 'verbose'
        },
    },
    'loggers': {  # 日志器
        'django': {  # 定义了一个名为django的日志器
            'handlers': ['console', 'file'],  # 可以同时向终端与文件中输出日志
            'propagate': True,  # 是否继续传递日志信息
            'level': 'INFO',  # 日志器接收的最低日志级别
        },
    }
}

-------------------------------------------------------------- 查看 日志 文件

 - 不同的应用程序所定义的日志等级可能会有所差别，分的详细点的会包含以下几个等级：

FATAL/CRITICAL = 重大的，危险的
ERROR = 错误
WARNING = 警告
INFO = 信息
DEBUG = 调试
NOTSET = 没有设置

import logging

# 创建日志记录器
logger = logging.getLogger('django')
# 输出日志
logger.debug('测试logging模块debug')
logger.info('测试logging模块info')
logger.error('测试logging模块error')

-------------------------------------------------------------- 设置访问的域名

 - 不写的话默认 127.0.0.1 
 - 写的话需要写入 127.0.0.1 的
ALLOWED_HOSTS = ['www.meiduo.site','127.0.0.1']

-------------------------------------------------------------- 前端 CORS 跨域问题解决

安装                  pip install django-cors-headers
# 添加应用
INSTALLED_APPS = (
    ...
    'corsheaders',
    ...
)
# 中间层设置 ( 放到最上面 )
MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    ...
]
# 添加白名单
# CORS
CORS_ORIGIN_WHITELIST = (
    'http://127.0.0.1:8080',
    'http://localhost:8080',
    'http://www.meiduo.site:8080',
    'http://www.meiduo.site:8000'
)
CORS_ALLOW_CREDENTIALS = True  # 允许携带cookie

 - 凡是出现在白名单中的域名，都可以访问后端接口
 - CORS_ALLOW_CREDENTIALS 指明在跨域访问中，后端是否支持对cookie的操作。

-------------------------------------------------------------- Django 原生密码加密

 - 使用 create_user 即可
User.objects.create_user(username=username,password=password,mobile=mobile)


-------------------------------------------------------------- 代码连接 redis

 - 链接 redis ( 默认是 default )

from django_redis import get_redis_connection
redis_cli = get_redis_connection('code') <- 选择库,不写默认 default 配置信息

#指令,限时 name , time/秒 , value
redis_cli.setex(Key, 最大生存时间/秒, Value)


-------------------------------------------------------------- HttpResponse - content_type 选项详细化

 - 大类接小类    例子: .text = text/plain
 - 请在网上搜索 MIME 以得以使用
 - return HttpResponse(image, content_type='image/jpeg')

-------------------------------------------------------------- 图片验证码后端逻辑

 - 借助第三方平台进行首发短信
 - 我 没钱 邮箱
 - https://www.yuntongxun.com/
 - 工具包里面以存放文件

 - 流程
  - 获取前端发过来的 image_code 以和 uuid <- image_code是用户输入的图形验证码,uuid 是图片的 redis 库的键 
  - 进行两方的全部非空判断
  - 连接 redis 根据 uuid 以取得值 ( 二进制文件需要解码 ), 判断是否为空( is None )
  - 需要将解码之后的数据库中 密码小写化( .decode().lower() ), 与用户写的验证码小写化进行比对 ( .lower() )
  - 比对成功之后编写接下来的业务逻辑

-------------------------------------------------------------- 避免恶意多次发送短信

 - 根据手机号拼接新字段写入 redis数据库,  send_flag_phoneNumber
     - 限制最大生存时间, 在生存周期之内无法再次发送短信
send_flag = redis.get()
if send_flag is not None:

-------------------------------------------------------------- pipeline 管道技术操作 Redis

 - 目前存在的问题
     - 如果Redis服务端需要同时处理多个请求，加上网络延迟，那么服务端利用率不高，效率降低。
     - 发起一次请求就建立 TCP 连接
 - 解决的办法：
     - 管道pipeline
         - 可以一次性发送多条命令并在执行完后一次性将结果返回。
         - pipeline通过减少客户端与Redis的通信次数来实现降低往返延时时间。
 - 实现的原理
     - 实现的原理是队列。
         - Client可以将三个命令放到一个tcp报文一起发送。
         - Server则可以将三条命令的处理结果放到一个tcp报文返回。
         - 队列是先进先出，这样就保证数据的顺序性。


 - 管道技术
     - 新建管道 pipeline = redis_cli.pipeline()
 - 管道收集指令
     - 将原先 redis_cli 替换为 pipeline
         - pipeline.setex(mobile, 300, sms_code)
         - pipeline.setex(f"send_flag_{mobile}",60,1)
 - 管道执行指令 pipeline.execute()

-------------------------------------------------------------- 生产者消费者模式( 耗时阻塞 )

问题：
 - 我们的代码是自上而下同步执行的。
 - 发送短信是耗时的操作。如果短信被阻塞住，用户响应将会延迟。
 - 响应延迟会造成用户界面的倒计时延迟。

解决：
 - 异步发送短信
 - 发送短信和响应分开执行，将发送短信从主业务中解耦出来。

-------------------------------------------------------------- 生产者消费者方案( 异步方案Celery )

 - 一个简单、灵活且可靠、处理大量消息的分布式系统，可以在一台或者多台机器上运行。
 - Celery是一个功能完备即插即用的任务队列
 - 单个 Celery 进程每分钟可处理数以百万计的任务。
 - 通过消息进行通信，使用消息队列（broker）在客户端和消费者之间进行协调。

-------------------------------------------------------------- Celery 实现异步发送

 - 在根目录创建单独的文件夹 celery_tasks
 - 内部存放文件 main.py  config.py  [名字]文件夹(专门存放 tasks.py 文件)

 - 在 main 文件中写入
 from celery import Celery

 # 为celery使用django配置文件进行设置
 import os
 os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'meiduo_mall.settings')

 # 创建celery实例  设置名字(这里就写路径吧)
 celery_app = Celery('celery_tasks')

 # 设置 broker 也就是队列的指定
 # 通过加载配置文件设置        路径
 app.config_from_object('celery_tasks.config')

 # 开始执行,添加生产者       路径, 自动检测 tasks 文件
 app.autodiscover_tasks(['celery_tasks.sms'])


 - 在 config 文件中写入
 #我们指定 redis 作为我们的队列        15号库
 broker_url = "redis://127.0.0.1:6379/15"


 - 在 [名字]文件夹(专门存放 tasks.py 文件) 文件里放入
     - 导包 将上面的 celery_app 变量导入进来, 需要它作为装饰器
     - 生产者
 from celery_tasks.main import app
 @app.task
 def celery_send_sms_code(mobie,code):
    CCP().send_template_sms(mobie, [f'{code}', 5], 1)


 - 开启 celery ( 消费者准备 )
 - 跑到跟文件
 celery -A celery_tasks.main worker -l info   (虚拟环境使用)
    1. -A 指对应的应用程序, 其参数是项目中 Celery 实例的位置。
    2. worker 指这里要启动的 worker。
    3. -l 指日志等级，比如info等级。



 - 一切准备完毕之后理所当然的应当要添加任务了
 - 请将之前需要分开的同步代码改为
 from celery_tasks.sms.tasks import celery_send_sms_code
 # 添加任务 - 执行参数
 celery_send_sms_code(mobile,sms_code)



1. main.py 配置 - config 解耦
2. [名字]文件夹(专门存放 tasks.py 文件) 这里是生产者的 业务逻辑 (没有使用)
3. 指令就是 使用配置文件redis队列 消费生产的代码 
4. 同步文件 修改独立化 添加生产者( 使用 )

生产 - redis作为队列 - 消费(芹菜执行)

5. 补充celery worker的工作模式
 - 默认是进程池方式，进程数以当前机器的CPU核数为参考，每个CPU开四个进程。
 - 如何自己指定进程数： celery worker -A proj --concurrency=4
 - 如何改变进程池方式为协程方式： celery worker -A proj --concurrency=1000 -P eventlet -c 1000
 - # 安装eventlet模块
 - $ pip install eventlet

 - # 启用 Eventlet 池
 - $ celery -A celery_tasks.main worker -l info -P eventlet -c 1000

-------------------------------------------------------------- 登陆

 - 判断用户输入的是用户名还是电话号码
 - User.USERNAME_FIELD="mobile"/"username"(默认)                   设置查询字段
 - from django.contrib.auth import authenticate                    导入 Django 的自带验证库, 因为加密也是他加的
user = authenticate(username=username,password=password)           提供的查询方式(上方可以设置)
    if user is None:                                               没有查到或密码不对就返回 
        return JsonResponse({'code':400,'errmsg':'账号或密码错误'}) 

    from django.contrib.auth import login                           导入 Django 自带的状态保持库
    login(requests,user)
    if remembered:                                                  前端选择是否记住密码
        requests.session.set_expiry(None)                           设置时间
    else:
        requests.session.set_expiry(0)



