 - 在没有 session 或 cookie 的 时候请检查电脑的 host 文件 之类的, 一定要在同源
 - get 或 post 之类的一定要携带一个参数 一般为 request

 - python manage.py shell	所见即所得

----------------------------------------------------------------------- 视图定义 get 与 post 注意

class LoginView(View):
    def post(self,requests):
        return HttpResponse("ok")
    def get(self,requests):
    	return HttpResponse("ok")

 - 注意参数必须要有一个

----------------------------------------------------------------------- 关于用户名与密码设置
	1.django 自带一个用户模型
	2.这个用户模型 有密码的加密 和 密码的验证
		 - from django.contrib.auth.models import User
		 	 - 有可能内部所使用的无法满足我们的需求, 比如没有 email模型, 那么重写与继承
		 - from django.contrib.auth.models import AbstractUser			
class User(AbstractUser):
	email = models.CharField(max_length=11, unique=True)

	# 改变表名
    class Meta:
        db_table = 'tb_users' 


异常解决:
	自定义模型类与 Django 原生 Users 继承一致导致报错 (fields.E304)
		 - 请在 Setting.py 文件中写入 AUTH_USER_MODEL = 'app名字.模型类的名字' 
		 - python manage.py makemigrations users	 = 只用一次
		 - python manage.py migrate


 - 如果根据上面写入, 那么假设加入数据成功时, 数据库将显示为
 id    					1
 password 				123456789
 last_login				NULL
 is_superuser			0
 username				Monika
 first_name
 last_name
 email
 is_staff				0
 is_active				1
 date_joined			2022-11-15 09:15:38.279283
 mobile					18629421525

-------------------------------------------------------------- 检查密码

对于 user = User.objects.create_user(username=mobile,mobile=mobile,password=password) 的检测密码
     - 由于密码加密, 所以我们仍然需要 Django 的方法解密
user.check_password(password)  

----------------------------------------------------------------------- 关于接口的风格
 - restful 风格
 - 多使用 名词的复数形式

 GET /goods/4 			前端获取后端指定产品
 GET /goods				前端获取后端所有产品

 POST /goods/ 			前端发送数据保存到后端

 PUT /goods/4  			前端修改后端保存的数据

 DELETE /goods/4  		前端删除后端保存的指定数据

-------------------------------------------------------------- 前端 CORS 跨域问题解决

安装                  pip install django-cors-headers
# 添加应用
INSTALLED_APPS = (
    ...
    'corsheaders',
    ...
)
# 中间层设置 ( 放到最上面 )
MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    ...
]
# 添加白名单
# CORS
CORS_ORIGIN_WHITELIST = (
    'http://127.0.0.1:8080',
    'http://localhost:8080',
    'http://www.meiduo.site:8080',
    'http://www.meiduo.site:8000'
)
CORS_ALLOW_CREDENTIALS = True  # 允许携带cookie

 - 凡是出现在白名单中的域名，都可以访问后端接口
 - CORS_ALLOW_CREDENTIALS 指明在跨域访问中，后端是否支持对cookie的操作。

-------------------------------------------------------------- 收集前端数据并进行非空校验

 def post(self,request):
        body_dist = JSON.loads(request.body.decode())
        username = body_dist.get('username')
       	...

        if not all([username,password,password2,mobile,allow]): 			#一旦出现 None 或 False 则 all 返回 False
            return JsonResponse({'code':1,'errorMsg':"请勿绕过前端界面"})


        return JsonResponse({'code':0,'errorMsg':'ok'})

-------------------------------------------------------------- Django 原生密码加密

 - 使用 create_user 即可
User.objects.create_user(username=username,password=password,mobile=mobile)

-------------------------------------------------------------- 图片验证码

 - 接受路由中的 uuid									请求
 - 生成图片验证码和图片二进制, 保存在 rides 中 			业务逻辑
 - 返回图片二进制										响应

请将工具包中的 生成图片验证码 解压近你所认定为第三方库的地方 - libs
 - pip install pillow

from libs.captcha.captcha import captcha
text, image = captcha.generate_captcha()			文本内容 与 二进制

 - 链接 redis ( 默认是 default )

from django_redis import get_redis_connection
redis_cli = get_redis_connection('code') <- 选择库,不写默认 default 配置信息

#指令,限时 name , time/秒 , value
redis_cli.setex(uuid, 100, text)

'image/jpeg'     'image/gif'     'image/png'
 - 二进制文件请用 HttpResponse(image,content_type='image/jpeg')

使用案例:
class ImageCodeView(View):
    def get(self, requests ,uuid):
        from libs.captcha.captcha import captcha   					#导入 二维码 生成第三方库
        text, image = captcha.generate_captcha()   					#接收 
        from django_redis import get_redis_connection  				#
        redis_cli = get_redis_connection('code')
        redis_cli.setex(uuid, 100, text)
        return HttpResponse(image,content_type='image/jpeg')

-------------------------------------------------------------- 图片验证码后端逻辑

 - 借助第三方平台进行首发短信
 - 我 没钱 邮箱
 - https://www.yuntongxun.com/
 - 工具包里面以存放文件

 - 流程
  - 获取前端发过来的 image_code 以和 uuid <- image_code是用户输入的图形验证码,uuid 是图片的 redis 库的键 
  - 进行两方的全部非空判断
  - 连接 redis 根据 uuid 以取得值 ( 二进制文件需要解码 ), 判断是否为空( is None )
  - 需要将解码之后的数据库中 密码小写化( .decode().lower() ), 与用户写的验证码小写化进行比对 ( .lower() )
  - 比对成功之后编写接下来的业务逻辑

-------------------------------------------------------------- 避免恶意多次发送短信

 - 根据手机号拼接新字段写入 redis数据库,  send_flag_phoneNumber
     - 限制最大生存时间, 在生存周期之内无法再次发送短信
send_flag = redis.get()
if send_flag is not None:

-------------------------------------------------------------- 生产者消费者模式

问题：
 - 我们的代码是自上而下同步执行的。
 - 发送短信是耗时的操作。如果短信被阻塞住，用户响应将会延迟。
 - 响应延迟会造成用户界面的倒计时延迟。

-------------------------------------------------------------- 登陆

 - 判断用户输入的是用户名还是电话号码
 - User.USERNAME_FIELD="mobile"/"username"(默认)                   设置查询字段
 - from django.contrib.auth import authenticate                    导入 Django 的自带验证库, 因为加密也是他加的
user = authenticate(username=username,password=password)           提供的查询方式(上方可以设置)
    if user is None:                                               没有查到或密码不对就返回 
        return JsonResponse({'code':400,'errmsg':'账号或密码错误'}) 

    from django.contrib.auth import login                           导入 Django 自带的状态保持库
    login(requests,user)
    if remembered:                                                  前端选择是否记住密码
        requests.session.set_expiry(None)                           设置时间
    else:
        requests.session.set_expiry(0)


-------------------------------------------------------------- 展示登陆信息

 - 这里是 Vue 读取 Cookie 信息得知用户已经登陆的方案, 之前我的网站是 ... 
 	 - 好吧之前我那写的是个什么锤子 ?
 - 只不过现在好像用到的都是 Token 了
 - 就是吧数据写到 Cookie 上就是了

-------------------------------------------------------------- 退出登陆

 - 当用户退出登陆的时候 axios 发送 delete 请求
from django.contrib.auth import logout
class LogoutView(View):
    def delete(self,request):
        #删除 Session
        logout(request)
        response = JsonResponse({'code':0, 'errmsg':"ok"})
        #删除 Cookie
        response.delete_cookie('username')
        return response

-------------------------------------------------------------- 用户界面权限问题


from django.contrib.auth.mixins import LoginRequiredMixin
 # - 但是 LoginRequiredMixin 未登录返回的是一个重定向, 并不是 JSON 数据
 	 # - 我们需要 JSON
 	 # - 重写类方法就可以啦

- 1. 重写 LoginRequiredMixin
from django.contrib.auth.mixins import AccessMixin
class LoginRequiredJSONMixin(AccessMixin):
    """Verify that the current user is authenticated."""
    def dispatch(self, request, *args, **kwargs):
        if not request.user.is_authenticated:
            return JsonResponse({'code':0,'errmsg':'没有登陆捏 ~'})
        return super().dispatch(request, *args, **kwargs)

- 1. 重写 LoginRequiredMixin 内部函数 self.handle_no_permission()
from django.contrib.auth.mixins import LoginRequiredMixin
class LoginRequiredJSONMixin(LoginRequiredMixin):
    def handle_no_permission(self):
       return JsonResponse({'code':0,'errmsg':'没有登陆捏 ~'})



class CenterView(LoginRequiredMixin,View):
    def

-------------------------------------------------------------- 第三方登陆

 - 查看文档
 	 - https://wiki.connect.qq.com/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C_oauth2-0
 	 - 查看文档即可，下面只是给一些看文档思路

 - 准备工作
# QQ登录参数
# 我们申请的 客户端id
QQ_CLIENT_ID = '101474184'
# 我们申请的 客户端秘钥
QQ_CLIENT_SECRET = 'c6ce949e04e12ecc909ae6a8b09b637c'
# 我们申请时添加的: 登录成功后回调的路径
QQ_REDIRECT_URI = 'http://www.meiduo.site:8080/oauth_callback.html'
111111111111111111111111111111111111111111111111111111
 - 放置 QQ 前端登陆
 - 获取 Authorization Code
	 - 请求地址： PC网站：https://graph.qq.com/oauth2.0/authorize
	 - 请求方法： GET
	 - 传参方式： Query参数

response_type		必须	授权类型，此值固定为“code”。
client_id			必须	申请QQ登录成功后，分配给应用的appid。
redirect_uri		必须	成功授权后的回调地址，必须是注册appid时填写的主域名下的地址，
						 - 建议设置为网站首页或网站的用户中心。注意需要将url进行URLEncode。
state				必须	client端的状态值。用于第三方应用防止CSRF攻击，
						 - 成功授权后回调时会原样带回。请务必严格按照流程检查用户与state参数状态的绑定。
scope				可选	请求用户授权时向用户显示的可进行授权的列表。
display				可选	仅PC网站接入时使用,用于展示的样式。
						 - 如果传入“mobile”，则展示为mobile端下的样式, 不传则默认展示为PC下的样式
返回说明：
 -  如果用户成功登录并授权，则会跳转到指定的回调地址，并在redirect_uri地址后带上Authorization Code和原始的state值。如：
	 - PC网站：http://graph.qq.com/demo/index.jsp?code=9A5F************************06AF&state=test
注意：此code会在10分钟内过期()
222222222222222222222222222222222222222222222222222222
 - 通过Authorization Code获取Access Token
 - 请求地址： PC网站：https://graph.qq.com/oauth2.0/token
 - 请求方法：GET
 - 请求参数：
请求参数请包含如下内容：
 - grant_type	必须	授权类型，在本步骤中，此值为“authorization_code”。
 - client_id	必须	申请QQ登录成功后，分配给网站的appid。
 - client_secret	必须	申请QQ登录成功后，分配给网站的appkey。
 - code	必须	上一步返回的authorization code。
		 - 如果用户成功登录并授权，则会跳转到指定的回调地址，并在URL中带上Authorization Code。
		 - 例如，回调地址为www.qq.com/my.php，则跳转到：
		 - http://www.qq.com/my.php?code=520DD95263C1CFEA087******
注意此code会在10分钟内过期。
redirect_uri	必须	与上面一步中传入的redirect_uri保持一致。
fmt	可选	因历史原因，默认是x-www-form-urlencoded格式，如果填写json，则返回json格式

返回说明：
 - 如果成功返回，即可在返回包中获取到Access Token。 如(不指定fmt时）：
 - access_token=FE04************************CCE2&expires_in=7776000&refresh_token=88E4************************BE14
 - 参数说明	描述
 - access_token			授权令牌，Access_Token。
 - expires_in			该access token的有效期，单位为秒。
 - refresh_token		在授权自动续期步骤中，获取新的Access_Token时需要提供的参数。
							 - 注：refresh_token仅一次有效


-------------------------------------------------------------- 第三方登陆 QQ 例子

class QQLoginURLView(View):
    def get(self,requests):
    	# 协助 QQ 登陆的库 QQLoginTool Django笔记，settings 位置集中处理
        qq = OAuthQQ(client_id=settings.QQ_CLIENT_ID,client_secret=settings.QQ_CLIENT_SECRET,redirect_uri=settings.QQ_REDIRECT_URI, state='xxxxxx')
        qq_login_url = qq.get_qq_url()
        # 前端将用户想要 QQ 登陆意向发送给后端，后端返回 QQ 登陆的官方链接
        return JsonResponse({'code':0,'errmsg':'ok','login_url':qq_login_url})


class OauthQQView(View):
	#这里是 QQ 在用户登陆完之后, 将 code 发送给 前端(query), 前端再次发送给后端
    def get(self,requests):
        code = requests.GET.get('code')
        if code is None:
            return JsonResponse({'code':400,'errmsg':'参数不全'})
        qq = OAuthQQ(client_id=settings.QQ_CLIENT_ID,
                     client_secret=settings.QQ_CLIENT_SECRET,
                     redirect_uri=settings.QQ_REDIRECT_URI,
                     state='xxxxxx')	#state 仍旧不知道怎么用
        token = qq.get_access_token(code)	# 获取 Token 
        openid = qq.get_open_id(token)		# 获取 用户 openid 一一对应的
        # 绑定过就直接登陆, 没有就需要绑定
        # D0F21A7F37C761BFBFB87B3DEE3ECF69 这是 自己的 openid 示例
        # D0F21A7F37C761BFBFB87B3DEE3ECF69 两次登陆，一模一样

-------------------------------------------------------------- 模型类外键补充

apps
	oauth 
		models.py
	users
		models.py
	...
		...

oauth - models.py 中外键可以 远程链接 users - models.py

											子应用名.模型名
oauth - models.py = user = models.ForeignKey('users.User', on_delete=models.CASCADE, verbose_name='用户')


-------------------------------------------------------------- 对于 数据库 修改的便捷方式

 - 在登陆的状态下, 也就是需要 LoginRequiredJSONMixin 加入

class EmailView(LoginRequiredJSONMixin,View):
    def put(self, requests):
        data = JSON.loads(requests.body.decode())
        email = data.get('email')
        user = requests.user
        user.email = email
        user.save()

-------------------------------------------------------------- 对于省市区的数据表构建方式

  id 				 name 				parent_id
10000				河北省			      NULL

10100				保定市			      10000
10200				石家庄市				  10000
10300				唐山市				  10000

10101				雄县					  10100
10102				安新县				  10100

// 定义外键新方式
parent = models.ForeignKey('self', related_name='subs')

class Area(models.Model):
    """省市区"""
    name = models.CharField(max_length=20, verbose_name='名称')
    parent = models.ForeignKey('self', on_delete=models.SET_NULL, related_name='subs', null=True, blank=True, verbose_name='上级行政区划')

    class Meta:
        db_table = 'tb_areas'
        verbose_name = '省市区'
        verbose_name_plural = '省市区'

    def __str__(self):
        return self.name

 - 根据 name 查 parent_id = id
 - 查出来之后的 id 进行了 外键










