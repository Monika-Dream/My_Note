----------------------------------------------------------------------- 视图定义 get 与 post 注意

class LoginView(View):
    def post(self,requests):
        return HttpResponse("ok")
    def get(self,requests):
    	return HttpResponse("ok")

 - 注意参数必须要有一个

----------------------------------------------------------------------- 关于用户名与密码设置
	1.django 自带一个用户模型
	2.这个用户模型 有密码的加密 和 密码的验证
		 - from django.contrib.auth.models import User
		 	 - 有可能内部所使用的无法满足我们的需求, 比如没有 email模型, 那么重写与继承
		 - from django.contrib.auth.models import AbstractUser			
class User(AbstractUser):
	email = models.CharField(max_length=11, unique=True)

	# 改变表名
    class Meta:
        db_table = 'tb_users' 


异常解决:
	自定义模型类与 Django 原生 Users 继承一致导致报错 (fields.E304)
		 - 请在 Setting.py 文件中写入 AUTH_USER_MODEL = 'app名字.模型类的名字' 
		 - python manage.py makemigrations users	 = 只用一次
		 - python manage.py migrate


 - 如果根据上面写入, 那么假设加入数据成功时, 数据库将显示为
 id    					1
 password 				123456789
 last_login				NULL
 is_superuser			0
 username				Monika
 first_name
 last_name
 email
 is_staff				0
 is_active				1
 date_joined			2022-11-15 09:15:38.279283
 mobile					18629421525


----------------------------------------------------------------------- 关于接口的风格
 - restful 风格
 - 多使用 名词的复数形式

 GET /goods/4 			前端获取后端指定产品
 GET /goods				前端获取后端所有产品

 POST /goods/ 			前端发送数据保存到后端

 PUT /goods/4  			前端修改后端保存的数据

 DELETE /goods/4  		前端删除后端保存的指定数据

-------------------------------------------------------------- 前端 CORS 跨域问题解决

安装                  pip install django-cors-headers
# 添加应用
INSTALLED_APPS = (
    ...
    'corsheaders',
    ...
)
# 中间层设置 ( 放到最上面 )
MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    ...
]
# 添加白名单
# CORS
CORS_ORIGIN_WHITELIST = (
    'http://127.0.0.1:8080',
    'http://localhost:8080',
    'http://www.meiduo.site:8080',
    'http://www.meiduo.site:8000'
)
CORS_ALLOW_CREDENTIALS = True  # 允许携带cookie

 - 凡是出现在白名单中的域名，都可以访问后端接口
 - CORS_ALLOW_CREDENTIALS 指明在跨域访问中，后端是否支持对cookie的操作。

-------------------------------------------------------------- 收集前端数据并进行非空校验

 def post(self,request):
        body_dist = JSON.loads(request.body.decode())
        username = body_dist.get('username')
       	...

        if not all([username,password,password2,mobile,allow]): 			#一旦出现 None 或 False 则 all 返回 False
            return JsonResponse({'code':1,'errorMsg':"请勿绕过前端界面"})


        return JsonResponse({'code':0,'errorMsg':'ok'})

-------------------------------------------------------------- Django 原生密码加密

 - 使用 create_user 即可
User.objects.create_user(username=username,password=password,mobile=mobile)

-------------------------------------------------------------- 图片验证码

 - 接受路由中的 uuid									请求
 - 生成图片验证码和图片二进制, 保存在 rides 中 			业务逻辑
 - 返回图片二进制										响应

请将工具包中的 生成图片验证码 解压近你所认定为第三方库的地方 - libs
 - pip install pillow

from libs.captcha.captcha import captcha
text, image = captcha.generate_captcha()			文本内容 与 二进制

 - 链接 redis ( 默认是 default )

from django_redis import get_redis_connection
redis_cli = get_redis_connection('code') <- 选择库,不写默认 default 配置信息

#指令,限时 name , time/秒 , value
redis_cli.setex(uuid, 100, text)

'image/jpeg'     'image/gif'     'image/png'
 - 二进制文件请用 HttpResponse(image,content_type='image/jpeg')

使用案例:
class ImageCodeView(View):
    def get(self, requests ,uuid):
        from libs.captcha.captcha import captcha   					#导入 二维码 生成第三方库
        text, image = captcha.generate_captcha()   					#接收 
        from django_redis import get_redis_connection  				#
        redis_cli = get_redis_connection('code')
        redis_cli.setex(uuid, 100, text)
        return HttpResponse(image,content_type='image/jpeg')

-------------------------------------------------------------- 图片验证码后端逻辑

 - 借助第三方平台进行首发短信
 - 我 没钱 邮箱
 - https://www.yuntongxun.com/
 - 工具包里面以存放文件

 - 流程
  - 获取前端发过来的 image_code 以和 uuid <- image_code是用户输入的图形验证码,uuid 是图片的 redis 库的键 
  - 进行两方的全部非空判断
  - 连接 redis 根据 uuid 以取得值 ( 二进制文件需要解码 ), 判断是否为空( is None )
  - 需要将解码之后的数据库中 密码小写化( .decode().lower() ), 与用户写的验证码小写化进行比对 ( .lower() )
  - 比对成功之后编写接下来的业务逻辑

-------------------------------------------------------------- 避免恶意多次发送短信

 - 根据手机号拼接新字段写入 redis数据库,  send_flag_phoneNumber
     - 限制最大生存时间, 在生存周期之内无法再次发送短信
send_flag = redis.get()
if send_flag is not None:

-------------------------------------------------------------- 生产者消费者模式

问题：
 - 我们的代码是自上而下同步执行的。
 - 发送短信是耗时的操作。如果短信被阻塞住，用户响应将会延迟。
 - 响应延迟会造成用户界面的倒计时延迟。

-------------------------------------------------------------- 登陆

 - 判断用户输入的是用户名还是电话号码
 - User.USERNAME_FIELD="mobile"/"username"(默认)                   设置查询字段
 - from django.contrib.auth import authenticate                    导入 Django 的自带验证库, 因为加密也是他加的
user = authenticate(username=username,password=password)           提供的查询方式(上方可以设置)
    if user is None:                                               没有查到或密码不对就返回 
        return JsonResponse({'code':400,'errmsg':'账号或密码错误'}) 

    from django.contrib.auth import login                           导入 Django 自带的状态保持库
    login(requests,user)
    if remembered:                                                  前端选择是否记住密码
        requests.session.set_expiry(None)                           设置时间
    else:
        requests.session.set_expiry(0)
